<?xml version="1.0" encoding="UTF-8"?>

<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 * Master build file for the OMERO.insight java client.
 * You can use this file to compile, run, test, and package the application
 * for distribution. Furthermore, you can generate all other project artifacts,
 * like documentation. Please refer to the usage target for further details.
 *
 *
 * DEPENDENCIES
 * This is an Ant build file and requires Ant 1.6 or later to run the build.
 * Furthermore, all the libraries listed in the lib.xml header have to be 
 * available to Ant.
 * There are several ways to link those libraries to the Ant's runtime, ranging
 * from the -lib switch on the Ant's command line to placing the jars under
 * {ANT_HOME}/lib or, even better, under {YOUR_HOME}/.ant/lib.  Please refer
 * to the Ant manual for details.
 *
 *
 * CHILD BUILD FILES
 * The various activities that make up the build process have been factored in
 * several child build files within this directory.  This master build file is
 * responsible for pulling them together in the right order.  Child build files
 * are required to:
 * 
 *  + Define a project name after the file name.  For example the project name
 *    of the child build in 'app.xml' is 'app'.
 *  + Define a properties namespace.  This is done by prefixing all properties
 *    defined within the child file with the child project's name.  This is
 *    important to avoid collisions, as Ant properties are global.
 *  + Check for availability of external properties.  If a child depends on
 *    properties defined elsewhere (another child file/master file), then it
 *    has to explicitly check that those properties have been defined and error
 *    if some is missing.  The checks are performed through checkdef tasks 
 *    placed at the beginning of the file and outside of any target.  This way,
 *    a broken dependency graph is likely to show up at import time in the 
 *    master build file.
 *  + Have a 'clean' target.  This target has to remove all output generated by
 *    the child's targets.
 *  + Have a 'usage' target.  This target echoes the list of available targets.
 *    That is, the list of all public targets within the child build.
 *  + Use the same conventions to denote public targets.  The conventions are 
 *    simple: public targets have a description attribute (private targets do
 *    not) and are listed by the usage target.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
<project name="OMERO.insight" default="usage" basedir="../" xmlns:ivy="antlib:org.apache.ivy.ant">
 
  <description>The OMERO.insight Java Client Project.</description> 
  
  <!-- The build directory.  Every target outputs below this directory. -->  
  <property name="build.dir" location="OUT"/>

  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   * The following properties define the mappings to the artifacts relevant
   * to the build.  These artifacts are contained in the local git repository
   * hosting this build file.  Here's a short description of contents of the 
   * git dirs that are relevant to the build:
   *   + root dir: Contains the README file.
   *   + build: Contains this master build file and all its children.
   *   + config: Container and agents configuration files.
   *   + launch: Scripts for launching the app and install instructions.
   *   + SRC: All java source files and app resources.
   *   + TEST: All test code and relative resources.  
   *
   * NOTE: The root namespace for properties defined in the master build file
   *       is 'base'.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <property name="native.lib.dir" location="${basedir}/../../lib/"/>
  <property name="base.build.dir" location="build"/> 
  <property name="base.config.dir" location="config"/>
  <property name="base.launch.dir" location="launch"/> 
  <property name="base.lib.dir" location="target/libs"/>
  <property name="base.runtimelib.dir" location="target/libs/runtime"/>
  <property name="base.src.dir" location="SRC"/>
  <property name="base.test.dir" location="TEST"/> 
  <property name="base.test.lib.dir" location="${base.lib.dir}/test"/>
 
 <property name="base.src.util.dir" location="SRC/org/openmicroscopy/shoola/util"/>
 <property name="base.src.svc.dir" location="SRC/org/openmicroscopy/shoola/svc"/> 

  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   * Include the OMERO properties so that we may use them. We're loading these
   * these here so that the below child tasks can use them.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <property file="${base.build.dir}/../../../etc/omero.properties"/>

  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
   * Include the tasks lib and all children. 
   * The inclusion order is important because some child files depend on 
   * properties defined by others and all child files check for the needed
   * external properties at import time.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <path id="insight.tools.path">
      <fileset dir="${base.build.dir}/../../../lib/repository">
            <include name="ant-contrib-*.jar"/>
            <include name="jarbundler*.jar"/>
      </fileset>
  </path>

  <mkdir dir="${base.lib.dir}"/>
  <mkdir dir="${base.runtimelib.dir}"/>
  <mkdir dir="${base.test.lib.dir}"/>

  <taskdef resource="net/sf/antcontrib/antcontrib.properties"
           classpathref="insight.tools.path"/>
  <taskdef resource="net/sf/antcontrib/antlib.xml"
           classpathref="insight.tools.path"/>

  <typedef file="${base.build.dir}/lib.xml"/>

  <!-- Needed for javac.version for <myjavac> -->
  <property file="${base.build.dir}/../../../etc/local.properties.example" />

  <import file="${base.build.dir}/app.xml"/>
  <import file="${base.build.dir}/test.xml"/>
  <import file="${base.build.dir}/dist.xml"/>

  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
   * Set the timestamp and create the build directory where all output will go. 
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <target name="init"> 
    <tstamp/>
	<condition property="java.not.ok" value="true">
	  <not>
	    <or>
	      <contains string="${ant.java.version}" substring="1.7"/>
	      <contains string="${ant.java.version}" substring="1.8"/>
	    </or>
	  </not>
	</condition>
	<fail if="java.not.ok" message="Must use JDK 1.7.x or higher to build."/>
    <mkdir dir="${build.dir}"/> 
  </target> 
 
  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   * Use Ivy to download any dependencies that we need and possibly override
     classpath definitions.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <target name="ivy-init" unless="ivy.done">
    <!-- Overriding this value will cause a completely different classpath to
    be used. -->
    <property name="ivy.resolver" value="local-resolver"/>
    <property name="ivy.done" value="done"/>
    <property name="ivy.dep.file" value="${base.build.dir}/ivy.xml"/>
    <path id="ivy.classpath">
        <fileset dir="${base.lib.dir}/ivy" includes="*.jar"/>
    </path>
    <taskdef resource="org/apache/ivy/ant/antlib.xml" uri="antlib:org.apache.ivy.ant" classpathref="ivy.classpath"/>
    <ivy:settings file="${base.build.dir}/ivysettings.xml" override="true"/>
  </target>

  <target name="ivy-get" depends="ivy-init">
    <ivy:retrieve pattern="${build.dir}/ivycache/[artifact]-[revision].[ext]" log="quiet" sync="true" symlink="false"/>
  </target>

  <target name="ivy-override" depends="ivy-init">
    <!-- Overrides classpaths that are created during file parsing (import).
    This could be more elegant, especially with regard to what goes into each
    classpath, but for hudson's purposes, it should initially suffice -->
    <ivy:resolve file="${base.build.dir}/ivy.xml" type="jar" log="quiet"/>
    <ivy:cachepath pathid="app.compile.classpath" transitive="true"/>
  </target>

  <target name="ivy-publish" depends="ivy-init">
    <macrodef name="ivyPub">
      <attribute name="artifactspattern"/>
      <sequential>
        <ivy:publish
          artifactspattern="@{artifactspattern}"
          srcivypattern="${base.build.dir}/ivy.xml"
          resolver="hudson-repository"
          pubrevision="${dist.bundle.version}"
          status="integration"
          overwrite="true"/>
      </sequential>
    </macrodef>
    <ivy:resolve file="${base.build.dir}/ivy.xml" type="jar" log="quiet"/>
    <ivyPub artifactspattern="${dist.dir}/omero.insight.jar"/>
    <ivy:resolve file="${base.build.dir}/ivy.xml" type="zip" log="quiet"/>
    <ivyPub artifactspattern="${dist.dir}/omero.insight-${dist.bundle.version}.zip"/>
  </target>

  <target name="ivy-build">
  <!-- "Build run by hudson in the omero-insight-integration job" -->
    <property name="ivy-resolver" value="hudson-repository"/>
    <antcall target="clean" inheritAll="true" inheritRefs="true"/>
    <antcall target="ivy-override" inheritAll="true" inheritRefs="true"/>
    <antcall target="dist" inheritAll="true" inheritRefs="true"/>
    <antcall target="ivy-publish" inheritAll="true" inheritRefs="true"/>
  </target>

  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
   * Build, test, and package the app.
   * We first remove any previous build artifact, then we go through the main 
   * trunk of the build process until the default app bundle is produced.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <target name="all"
          depends="clean,dist" 
          description="Build, test, and package the app.">
  </target>

  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
   * Remove all output generated by the last build.
   * This target first forwards a clean to all children and then deletes the 
   * ${build.dir}.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <target name="clean"
          depends="app.clean,test.clean,dist.clean" 
          description="Remove all output generated by last build.">
    <delete dir="${build.dir}"/>
  </target>
  
  <!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
   * Output a list of all available targets.
   * This is the list of all public targets available through this file or
   * any of the imported child files.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
  <target name="usage"
          depends="app.usage,test.usage,dist.usage" 
          description="List all available targets.">
    <echo level="info">
Global targets:
--------------- 
  all: Build, test, and package the app under ${dist.dir}.
  clean: Remove all output generated by the last build. 
    </echo> 
	<echo message="ant.java.version = ${ant.java.version}" />
    <echo message="ant.version = ${ant.version}" />
  </target> 
  
</project>
