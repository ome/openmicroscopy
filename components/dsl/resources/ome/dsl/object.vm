##
##  Copyright (c) 2007 Glencoe Software Inc. All rights reserved.
##  Use is subject to license terms supplied in LICENSE.txt
##
#*

TODO things to implement on @Entity
  indexes
   batch size
   where clauses (deleted)
  optimistic lock
  set cascade properly (no delete except links)

make sure all non-${type.properties} properties (ID/DESCRIPTION/NAME/ETC show up))
go through and check all semantics for couple of class, all details, and permissions
Must have model-psql.jar
setDefaultXYZ is a bit complicated if indexOf < 0 throw exception
will need upgrade scripts. A bit tough. java -jar OMERO3__8/upgrade.jar
Need static UUIDGenerator in some Spring context, if not, use UUID.random() directly
Add to constraints page that fields can't be all upper
Add BaseObject
make sure that DSL properly computers nullable/insertable/updatable for lists
integration testing for model (H2?) including filterSets, etc. (also needed in blitz)
remove the bidirectionality of lists
experimenter link needs to be a list/ordered for defaultness
prop.type needs to return IObject for links (unless we're trying covariance again)
remove all references to "tag" in the mapping files
make sure that the arrays are properly supported (like sets)
add unloaded
considering putting everything directly into the context rather than as an element of type
do we need to reverse the "both sides" logic in case of a list?

*#
##
##  SETUP
##
#set($ofilter = "${type.table}_owner_filter")
#set($gfilter = "${type.table}_group_filter")
#set($efilter = "${type.table}_event_filter")
#set($pfilter = "${type.table}_perms_filter")
##
##
##
/*
 *   This file was generated by dsl/resources/ome/dsl/object.vm
 * 
 *   Copyright (c) 2007 Glencoe Software Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 *
 */

package ${type.package};

import ome.conditions.*;
import ome.model.*;
import ome.model.internal.*;

#if(!$type.superclass && !$type.global)
/**
 * These filter definitions are used by the security system
 * to eliminate non-readable objects from queries. The regular
 * user does not need to worry about them, as they will be
 * injected directly into the SQL (not HQL)
 */
@org.hibernate.annotations.FilterDefs({
    @org.hibernate.annotations.FilterDef(name="${ofilter}", 
	    parameters=@org.hibernate.annotations.ParamDef( name="ownerId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${gfilter}",
	    parameters=@org.hibernate.annotations.ParamDef( name="groupId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${efilter}",
	    parameters=@org.hibernate.annotations.ParamDef( name="eventId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${pfilter}",
	    parameters=@org.hibernate.annotations.ParamDef( name="permsStr", type="java.lang.String" )),
#foreach( $prop in $type.classProperties )
#if($prop.one2Many)
    @org.hibernate.annotations.FilterDef(name="${ofilter}_${prop.nameUpper}",
	    parameters=@org.hibernate.annotations.ParamDef( name="ownerId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${gfilter}_${prop.nameUpper}",
	    parameters=@org.hibernate.annotations.ParamDef( name="groupId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${efilter}_${prop.nameUpper}",
	    parameters=@org.hibernate.annotations.ParamDef( name="eventId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${pfilter}_${prop.nameUpper}",
	    parameters=@org.hibernate.annotations.ParamDef( name="permsStr", type="java.lang.String" )),
#end
#end
})
##if(!$type.superclass)
#if(!$type.global)
@org.hibernate.annotations.Filters({
    // See the comments on filters above
    @org.hibernate.annotations.Filter(name="${ofilter}", condition=":ownerId = owner_id"),
    @org.hibernate.annotations.Filter(name="${gfilter}", condition=":groupId = group_id"),
    @org.hibernate.annotations.Filter(name="${efilter}", condition=":eventId = event_id"),
    @org.hibernate.annotations.Filter(name="${pfilter}", condition=":permsStr = permissions"),
    @org.hibernate.annotations.Filter(name="securityFilter")
})
#end
#end
@javax.persistence.Entity
@org.hibernate.annotations.Entity( selectBeforeUpdate = true )
@javax.persistence.Table(name = "${type.table}")
##
## Determine inheritance type
##
#if($type.superclass)
@javax.persistence.Inheritance(strategy=javax.persistence.InheritanceType.JOINED) 
#set($superId = ${type.typeToColumn($type.superclass)} )
@javax.persistence.PrimaryKeyJoinColumn(name="${superId}_id") 
#else
@javax.persistence.SequenceGenerator( 
    name="seq_${type.table}", 
    sequenceName="seq_${type.table}" 
) 
#end
#* TODO ADD SUPPORT FOR SINGLE TABLE CLASS
 *
 * @Inheritance(strategy=InheritanceType.SINGLE_TABLE) 
 * @DiscriminatorColumn( 
 * name="planetype", 
 * discriminatorType=DiscriminatorType.STRING 
 * ) 
 * @DiscriminatorValue("Plane") 
 * public class Plane { ... } 
 * @Entity 
 * @DiscriminatorValue("A320") 
 * public class A320 extends Plane { ... } 
*#
##
##
##
public #if($type.abstract)abstract#end class ${type.shortname}
#if($type.superclass)extends $type.superclass #end implements java.io.Serializable, IObject#if(!$type.immutable), IMutable#end#if($type.isEnum), IEnum#end#if($type.isLink), ILink#end
## TODO Could just have $type.interfaces here then $type.interfaces.contains("IEnum")
 {

   /* These values are defined in dsl/resources/ome/dsl/mapping.vm:
    * -------------------------------------------------------------
    * Explanation of serialVersionUID ex 0000000 03 00 00 01 03 01 L;
    * 1-7   : currently unused
    * 8-9   : major part (3.x.x)
    * 10-11 : minor part (x.0.x)
    * 12-13 : patch part (x.x.0)
    * 14-15 : release type   (B)
    * 16-17 : release number (3)
    * 18-19 : increment per delta // any changes to the dsl or mapping files
    */
    private static final long serialVersionUID = 0000000030000020301L;
	
#if(!$type.global)
   /*
    * Constants naming filters used by the OMERO
    * security system.
    */
    public final static String OWNER_FILTER = "${ofilter}";
    public final static String GROUP_FILTER = "${gfilter}";
    public final static String EVENT_FILTER = "${efilter}";
    public final static String PERMS_FILTER = "${pfilter}";
#end

	public ${type.shortname} () {        
    }

    // TODO explain that this leaves loaded. This actually shouldn't be public
    public ${type.shortname} (Long id) {
        setId(id);
        getDetails().setContext(this); // TODO Is this necessary? Use @Parent
    }

    public ${type.shortname} (Long id, boolean loaded) {
        this(id);
        if (!loaded) {
            if (this.id == null) {
                throw new ApiUsageException("Id cannot be null for a proxy");
            }
            unload();
        }
    }

    // TODO a ctor which takes all simple properties?

    // TODO ctor with UUID Type(UUID uuid) { } // which will be persisted perhaps as LSID? or just in ExternalInfo

#if($type.isEnum)
    public ${type.shortname} (String value) {
        setValue(value);
    }
#end

#if(!${type.superclass})
	public final static String ID = "${type.id}_id";
	
    protected Long id;

   /**
    * The DB unique identifier for this object. You are not responsible for
    * setting the id; however, it can be useful for creating "unloaded"
    * versions of your objects.
    *
    * Each top-level entity contains an id field of type long.
    * For all objects returned from the server, this value will
    * be non-null, which doesn't necessarily hold for the other
    * fields.
    */
    @javax.persistence.Id
	@javax.persistence.GeneratedValue(
	    strategy=javax.persistence.GenerationType.SEQUENCE,
	    generator="seq_${type.table}") 
    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }
#end

   /**
    * Note: subclasses of this class can only return subclasses of 
	* this {@link Details} type.
	*/
   protected ${type.details} details = new ${type.details}();

   /**
    * The details of this object correspond to low-level system
    * information. Owner, permissions, Details is always guaranteed 
    * to be non-null, unless the user actively nulls it.
    *
    * Every entity also contains a Detail reference, which doesn't
    * refer to a separate table but rather to a collection of fields
    * collected into a Hibernate "component" which is embedded in the
    * object.
    *
    * HQL queries which refer to the Details component cannot directly
    * fetch the entity like this:
    *
    *    select o from Object join fetch o.details
    *
    * but rather each field of the Details instance must be explicitly
    * joined:
    *
    *    select o from Object join fetch o.details.owner
    *
    * It should also be noted that not all types have all the fields
    * which are present on Details. For example,
    *
    *    select e from Experimenter e join fetch e.details.owner
    *
    * will fail. Experimenter has no owner, for obvious reasons.
    */
    @javax.persistence.Embedded
    public ${type.details} getDetails() {
        return this.details;
    }

    public void setDetails(GlobalDetails details) throws ClassCastException { // TODO rename BaseDetails
        this.details = (MutableDetails) details;
    }

   /*
    *    INTERFACE-BASED
    *    Several properties are defined by whether or not
    *    the OME definition has certain interfaces.
    */

#if(!${type.immutable} && !${type.superclass})
    protected Integer version = 0; // TODO?

   /**
    * This version number is controlled by the database for optimisitic
    * locking.
    */
    @javax.persistence.Version 
    @javax.persistence.Column(name="version") 
//TODO mark off #118 if this succeeds, otherwise, completely remove versions and test updateEvent
    public Integer getVersion() {
        return this.version;
    }

    public void setVersion(Integer version) {
        this.version = version;
    }

#end

#if($type.named)
	
    public final static String NAME = "${type.id}_name";
	
    protected String name;
 
    @javax.persistence.Column( nullable = false, length = 256, name = "name")
    public String getName() {
        preGetter( NAME );
        return this.name;
    }

    public void setName(String name) {
        preSetter( NAME, name );
        this.name = name;
    }
#end

#if($type.described)
	
    public final static String DESCRIPTION = "${type.id}_description";
	
    protected String description;
 
    @javax.persistence.Column( nullable = false, length = 256, name = "description")
    public String getDescription() {
        preGetter( DESCRIPTION );
        return this.description;
    }

    public void setDescription(String description) {
        preSetter( DESCRIPTION, description );
        this.description = description;
    }
#end

   /*
    *    PROPERTIES
    *    All properties which follow are straight-forward
    *    and can be understood using only the Hibernate
    *    documentation.
    */

#foreach($prop in $type.classProperties)#######################################EACH
##
##  Now we iterate throug each of the properties and based on the type we 
##  generate the appropriate methods.
##

    protected ${prop.fieldType} ${prop.name};

#if($prop.class.name == "ome.dsl.EntryField")#############################TYPE
##
##  EntryFields are handled by ome/dsl/data.vm, since each of the entries isn't
##  a real property but rather an enum value for the database. However, they 
##  are not even returned by $type.classProperties only $type.properties
##
#elseif($prop.one2Many)###################################################TYPE
##
## TODO IS this all_delete_orphan
#set( $cascadeEjb = "javax.persistence.CascadeType.MERGE, javax.persistence.CascadeType.PERSIST, javax.persistence.CascadeType.REFRESH" )
#if($prop.isLink)
#set( $cascadeHib = "org.hibernate.annotations.CascadeType.ALL, org.hibernate.annotations.CascadeType.DELETE_ORPHAN" )
#else
#set( $cascadeHib = "org.hibernate.annotations.CascadeType.LOCK, org.hibernate.annotations.CascadeType.MERGE, org.hibernate.annotations.CascadeType.PERSIST, org.hibernate.annotations.CascadeType.REPLICATE, org.hibernate.annotations.CascadeType.REFRESH, org.hibernate.annotations.CascadeType.SAVE_UPDATE" );
#end
##
#if(!${type.global})
   /*
    * Filter names which are used by the security system to turn on filters
    * for this particular collection.
    */
    public final static String OWNER_FILTER_${prop.nameUpper} = "${ofilter}_${prop.nameUpper}";
    public final static String GROUP_FILTER_${prop.nameUpper} = "${gfilter}_${prop.nameUpper}";
    public final static String EVENT_FILTER_${prop.nameUpper} = "${efilter}_${prop.nameUpper}";
    public final static String PERMS_FILTER_${prop.nameUpper} = "${pfilter}_${prop.nameUpper}";
#end

   /**
    * returns ${prop.name} . You should not modify this collection unless you
    * know what you are doing. Use the iterate method instead.
    *
##
#if($prop.ordered)
    * one-to-many List ${type.id}.${prop.name} (${prop.type})
    * Values are indexed by the column "index" on ${prop.type}
    */
    @javax.persistence.OneToMany(fetch=javax.persistence.FetchType.LAZY, cascade={${cascadeEjb}})
    @org.hibernate.annotations.Cascade({$cascadeHib})
    @org.hibernate.annotations.IndexColumn(name="index", nullable=false)
#else
    * one-to-many Set ${type.id}.${prop.name} (${prop.type})
    */
    @javax.persistence.OneToMany(mappedBy="${prop.foreignKey}", fetch=javax.persistence.FetchType.LAZY, cascade={${cascadeEjb}})
    @org.hibernate.annotations.Cascade({$cascadeHib})
#end
##
##
#if(!$type.global)
## TODO Can these be set on list 
    @org.hibernate.annotations.Filters({
        @org.hibernate.annotations.Filter(name="securityFilter"),
        @org.hibernate.annotations.Filter(name=OWNER_FILTER_${prop.nameUpper}, condition=":ownerId = owner_id"),
        @org.hibernate.annotations.Filter(name=GROUP_FILTER_${prop.nameUpper}, condition=":groupId = group_id"),
        @org.hibernate.annotations.Filter(name=EVENT_FILTER_${prop.nameUpper}, condition=":eventId = event_id"),
        @org.hibernate.annotations.Filter(name=PERMS_FILTER_${prop.nameUpper}, condition=":permsStr = permissions")
    })
#end
   protected ${prop.fieldType} get${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name};
    }

    /**
     * setter for ${prop.name} should be avoided. Does not fulfill normal semantics.
     */
    protected void set${prop.nameCapped}(${prop.fieldType} ${prop.name}) {
        preSetter( ${prop.nameUpper}, ${prop.name} );
        this.${prop.name} = ${prop.name};
    }
##
##  A one-to-many property represents a set that is contained by this entity.
##  These methods represent our handling of Hibernate's "inverse" sets
##  which do not act as expected with regards to getters & setters.
##
##  To prevent users from making mistakes like not properly setting both 
##  sides of a relationship, these fields are hidden, and only accessible via
##  the following methods. Methods fall into several categories: 
##    (A) general
##    (B) list-only
##    (C) link-based
##
##  (A) General one-to-many code
##  ----------------------------
##
    /**
     * returns the size of ${prop.name}. If less than zero, the Set was null.
     */
    public int sizeOf${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name} == null ? -1 : this.${prop.name}.size();
    }

    /**
     * should be used rather than accessing the ${prop.name} set directly.
     * This method will never return null, but rather will return an instance
     * of {@link ome.util.EmptyIterator}. To test for a null collection,
     * see of {@link #sizeOf${prop.nameCapped}()} is less than zero.
     */
    public java.util.Iterator<${prop.type}> iterate${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        if ( get${prop.nameCapped}() == null ) {
            return new ome.util.EmptyIterator<${prop.type}>();
        }
        return get${prop.nameCapped}().iterator(); // TODO should this be direct access
    }

    /**
     * takes a CBlock and calls the block once for each ${prop.type} while
     * collecting the results. If <code>block == null</code>, then the
     * iterator values themselves are collected. This method uses
     * {@link #iterate${prop.nameCapped}} internally and so will return a value
     * even if the underlying collection is null.
     */
	@SuppressWarnings("unchecked")
    public <E> java.util.List<E> collect${prop.nameCapped}(ome.util.CBlock<E> block) {

        preGetter( ${prop.nameUpper} );

        java.util.List<E> result = new java.util.ArrayList<E>();
        java.util.Iterator<${prop.type}> it = iterate${prop.nameCapped}();
        while ( it.hasNext() ) {
            IObject obj = (IObject) it.next();
            if ( block != null ) {
                result.add( block.call( obj ) );
            } else {
                result.add( (E) obj );
            }
        }
        return result;
    }

    /**
     * use instead of set${prop.nameCapped} . Makes the necessary
     * call on ${prop.type} as well.
     */
    public void add${prop.shortType}(${prop.type} target) {
        preSetter( ${prop.nameUpper}, target );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().add( target );
        target.set${prop.inverseCapped} ( this );
    }

    /**
     * use like add${prop.shortType}.
     */
    public void add${prop.shortType}Set(java.util.Collection<${prop.type}> targets) {
        preSetter( ${prop.nameUpper}, targets );
        if (get${prop.nameCapped}() == null) {
           throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().addAll( targets );
        java.util.Iterator<${prop.type}> it = targets.iterator();
        while ( it.hasNext() ) {
            ${prop.type} target = it.next();
            target.set${prop.inverseCapped} ( this );
        }
    }

    /**
     * removes a single element from this set and makes the inverse call on ${prop.type}
     */
    public void remove${prop.shortType}(${prop.type} target) {
        preSetter( ${prop.nameUpper}, target );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().remove( target );
        target.set${prop.inverseCapped} ( null );
    }

    /**
     * use like remove${prop.shortType}
     */
    public void remove${prop.shortType}Set(java.util.Collection<${prop.type}> targets ) {
        preSetter( ${prop.nameUpper}, targets );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().removeAll( targets );
        java.util.Iterator<${prop.type}> it = targets.iterator();
        while ( it.hasNext() ) {
            ${prop.type} target = it.next();
            target.set${prop.inverseCapped} ( null );
        }
    }

##	
## The following methods are overwritten separately by the link code (C) below
## and therefore are omitted here if this is a link property.
##
#if(!${prop.isLink})
    /**
     * clears the set.
     */
    public void clear${prop.nameCapped}() {
        preSetter( ${prop.nameUpper}, null );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().clear();
        java.util.Iterator<${prop.type}> it = iterate${prop.nameCapped}();
        while (it.hasNext()) {
            ${prop.type} target = it.next();
            target.set${prop.inverseCapped} ( null );
        }
    }
#end## End not link


##
##  (B) List-based code
##  -------------------
##
#if( ${prop.ordered} )
    /**
     * Gets the ${prop.type} at the given index.
     */
    public ${prop.type} get${prop.shortType}(int index)
	throws IndexOutOfBoundsException {
        preGetter( ${prop.nameUpper} );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        return get${prop.nameCapped}().get(index);
    }

	/**
     * Sets the ${prop.type} at the given index. Adheres to the {@link List\#set(int ,E))}
	 * contract. To extend the list, use {@link #add${prop.shortType}()}.
	 * @see java.util.List\#set(int, E)
     */
    public void set${prop.shortType}(int index, ${prop.type} element) 
	throws IndexOutOfBoundsException {
        preSetter( ${prop.nameUpper}, index );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().set(index, element);
    }

    /**
     * Gets the first element of ${prop.name} which can be interpreted as the
     * primary or default element in some situations. If there is not first
	 * element, an {@link IndexOutOfBoundsException} is throws.
     */
    public ${prop.type} getPrimary${prop.shortType}()
    throws IndexOutOfBoundsException {
        preGetter( ${prop.nameUpper} );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        return get${prop.nameCapped}().get(0);
    }
    

    /**
     * Swaps the first element of ${prop.name} with the first instance of the 
	 * given element. If the given element is not in the list, an 
	 * {@link IndexOutBoundException} will be thrown. Returns the swapped 
	 * element.
     */
    public ${prop.type} setPrimary${prop.shortType}(${prop.type} element)
    throws IndexOutOfBoundsException {
        preGetter( ${prop.nameUpper} );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
		${prop.fieldType} list = get${prop.nameCapped}();
		int index = list.indexOf(element);
        ${prop.type} old = list.get(0);
		list.set(index, old);
		list.set(0, element);
		return old;
    }
    
	
## TODO 
## ListIterator<${prop.type}> listIterator${prop.nameCapped}()
## public int indexOf(${prop.type} elt)
## public int lastIndexOf(${prop.type} elt) 
## List<${prop.type}> subList${prop.nameCapped}}(int fromIndex, int toIndex)
#end
##
##
##  (C) Link-based code
##  -------------------
##
##  These methods are like the set methods above, but help to completely
##  hide the link implementations.
##
#if( $prop.isLink )
#set( $LinkType = ${prop.type} )
#set( $Link = ${prop.shortType} )
#set( $ElementType = ${prop.target})
#set( $Element = ${prop.shortTarget})
##
#if($prop.class.name == "ome.dsl.ChildLink" )
#set( $order = "this, addition" )
#set( $next = "parent" )
#set( $other = "child" )
#elseif($prop.class.name == "ome.dsl.ParentLink")
#set( $order = "addition, this" )
#set( $next = "child" )
#set( $other = "parent" )
#end
##
    /**
     * Adds a ${LinkType} to ${prop.name} . This entails changing our ${prop.name} Set,
     * creating a new ${LinkType} and calling link${Element} on the ${ElementType}.
     */
    public void link${Element} (${ElementType} addition) {
        preSetter( ${prop.nameUpper}, addition );

        // Setup link
        ${LinkType} link = new ${LinkType}();
        link.link( ${order} );

        // Add it to us and possibly the other side.
        add${Link}( link, true );

    }

    /**
     * Adds a ${LinkType} to ${prop.name}, allowing for recursion -- whether
     * or not add${prop.shortType} will be called on the addition <b>if it is loaded</b>
     */
    public void add${Link} (${LinkType} link, boolean bothSides) {
        preSetter( ${prop.nameUpper}, link );
        if ( get${prop.nameCapped}() == null ) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().add( link );

#if(${prop.bidirectional})
        if ( bothSides && link.${other}().isLoaded() ) {
            link.${other}().add${Link}( link, false );
        }
#end
    }

    /**
     * provides an iterator over the ${next} values of the ${prop.name}. Like
     * with most Collection iterators, modificiations to the underlying collection
     * while iterating will result in an {@link ConcurrentModificationException}.
     * Use {@link #linked${Element}List()} instead.
     */
     public java.util.Iterator<${ElementType}> linked${Element}Iterator() {
        preGetter( ${prop.nameUpper} );
        if ( get${prop.nameCapped}() == null ) {
            return new ome.util.EmptyIterator<${ElementType}>();
        }

        final java.util.Iterator<${LinkType}> it = get${prop.nameCapped}().iterator();
        return new java.util.Iterator<${ElementType}>() {

            public boolean hasNext() {
                return it == null ? false : it.hasNext();
            }

            public ${ElementType} next() {
                if ( it == null ) {
                    throw new java.util.NoSuchElementException( "${prop.name} is null; no elements." );
                }
                ${LinkType} link = (${LinkType}) it.next();
                return link.${other}();
            }

            public void remove() {
                throw new UnsupportedOperationException("Cannot call remove on this iterator.");
            }

        };
    }

    /**
     * find all ${LinkType} which have the argument as their ${other}.
     */
    public java.util.Set<${LinkType}> find${Link}( ${ElementType} target ) {
        preGetter( ${prop.nameUpper} );

        final java.util.Iterator<${LinkType}> it = iterate${prop.nameCapped}();
        final java.util.Set<${LinkType}> result = new java.util.HashSet<${LinkType}>();
        while ( it.hasNext() ) {
            ${LinkType} link = it.next();
            if ( link.${other}() == target ) {
                result.add( link );
            }
        }
        return result;
    }

    /** 
     * produces a {@link List}-copy of the underlying collection. Unlike,
     * {@link #linked${Element}Iterator()}, while using the returned {@link List},
     * modifications can be made to the underlying collection without throwing
     * {@link ConcurrentModificationExceptions}
     */
    public java.util.List<${ElementType}> linked${Element}List() {
        preGetter( ${prop.nameUpper} );

        java.util.Iterator<${ElementType}> it = linked${Element}Iterator();
        java.util.List<${ElementType}> list = new java.util.ArrayList<${ElementType}>();

        while ( it.hasNext() ) {
            list.add( it.next() );
        }
        return list;
    }

    /**
     * takes a CBlock and calls the block once for each ${ElementType} while
     * collecting the results. If <code>block == null</code>, then the
     * iterator values themselves are collected.
     */
	@SuppressWarnings("unchecked")
    public <E> java.util.List<E> eachLinked${Element}(ome.util.CBlock<E> block) {
        preGetter( ${prop.nameUpper} );

        java.util.List<E> result = new java.util.ArrayList<E>();
        java.util.Iterator<${ElementType}> it = linked${Element}Iterator();
        while ( it.hasNext() ) {
            ${ElementType} obj = it.next();
            if ( block != null ) {
                result.add( block.call( obj ) );
            } else {
                result.add( (E) obj );
            }
        }
        return result;
    }

    /**
     * unlinks all ${ElementType} instances from this instance.
     */
    public void unlink${Element} (${ElementType} removal) {
        preSetter( ${prop.nameUpper}, removal );

        java.util.Set<${LinkType}> toRemove = find${Link}( removal );
        java.util.Iterator<${LinkType}> it = toRemove.iterator();
        while ( it.hasNext() ) {
            remove${Link}( it.next(), true );
        }
    }

    /**
     * removes the given ${Link} from ${prop.name}, allowing for recursion -- whether
     * or not the removal will call unlink${type.shortname} again <b>if loaded</b>.
     */
    public void remove${Link} (${LinkType} link, boolean bothSides) {
        preSetter( ${prop.nameUpper}, link );

        if ( get${prop.nameCapped}() == null ) {
            throwNullCollectionException("${prop.nameCapped}");
        }

        get${prop.nameCapped}().remove( link );

#if(${prop.bidirectional})
        if ( bothSides && link.${other}().isLoaded() ) {
            link.${other}().remove${Link}( link, false );
        }
#end
    }

    /**
     * clears the set.
     */
    public void clear${Element}Links() {
        preSetter( ${prop.nameUpper}, null );

        java.util.List<${LinkType}> list = new java.util.ArrayList<${LinkType}>( get${prop.nameCapped}() );
        for (${LinkType} link : list) {
            remove${Link}( link, true );
        }
    }
#end## End isLink
#elseif($prop.foreignKey)## REGULAR M-1 ##################################TYPE
   /**
    * Many-to-one field ${type.id}.${prop.name} (${prop.type})
    */
    // TODO @OrderBy
    @javax.persistence.ManyToOne( cascade = {} ) // TODO targetEntity = XYZImpl.class)
    @javax.persistence.JoinColumn(name="${prop.name}", nullable=${prop.nullable}, 
        unique=${prop.unique}, insertable=${prop.insert}, updatable=${prop.update})
    public ${prop.fieldType} get${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name};
    }

    public void set${prop.nameCapped}(${prop.fieldType} ${prop.name}) {
        preSetter( ${prop.nameUpper}, ${prop.name} );
        this.${prop.name} = ${prop.name};
    }
#else## REGULAR PROPERTY #################################################TYPE
   /**
    * Simple field ${type.id}.${prop.name} (${prop.type}) 
    */
    protected ${prop.type} ${prop.name};
    ${prop.typeAnnotation}}
    @javax.persistence.Column(columnDefinition="${prop.def}", nullable=${prop.nullable}, unique=${prop.unique}, name="${prop.name}", updatable=${prop.update})
    public ${prop.fieldType} get${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name};
    }

    public void set${prop.nameCapped}(${prop.fieldType} ${prop.name}) {
        preSetter( ${prop.nameUpper}, ${prop.name});
		if (!(${prop.name} instanceof ${prop.type}})) {
		    throw new ApiUsageException("${type.shortname}.set${prop.nameCapped}() accepts only ${prop.type} arguments.")
		}
        this.${prop.name} = (${prop.type}) ${prop.name};
    }
#end######################################################################TYPE
#end########################################################################EACH

    // TODO what does this look like with Validator
    public boolean isValid() {
        return ome.util.Validator.validate(this).isValid();
    }
  
    public ome.util.Validation validate() {
        return ome.util.Validator.validate(this);
    }

#if(!$type.abstract)
## TODO trying to return type and not superclass
## but javassist in hibernate has problems with covariant return types
## http://jboss.org/index.html?module=bb&op=viewtopic&t=83199
## http://www.jboss.org/index.html?module=bb&op=viewtopic&p=3950680
##
    public ${type.id} newInstance() 
    {
        return new ${type.id}();
    }

    public ${type.id} proxy() {
        return new ${type.id}(this.id, false);
    }
#end

    @SuppressWarnings("unchecked")
    public boolean acceptFilter(ome.util.Filter __filter){
#foreach($prop in $type.classProperties)
        this.$prop.name = (${prop.fieldType}) __filter.filter(${prop.name.toUpperCase()}, ${prop.name} ); 
#end
#if($type.superclass)
        return super.acceptFilter(__filter);
#else
        return true;
#end
    }

    @Override
    public String toString(){
        String name = this.getClass().getName();
        StringBuilder sb = new StringBuilder(name.length() + 24);
        sb.append(name);
        if (this.id == null) {
            sb.append(":Hash_");
            sb.append(this.hashCode()); 
        } else {
            sb.append(":Id_");
            sb.append(this.id);
        }
        return sb.toString();
    }
  
    // FIELD-FIELDS
  
    public java.util.Set<String> fields() {
        return ${type.id}.FIELDS;
    }
  
#foreach($prop in $type.classProperties)
    public final static String ${prop.nameUpper} = "${type.id}_${prop.name}";
#end

    public final static java.util.Set<String> FIELDS;
    static {
       java.util.Set<String> raw = new java.util.HashSet<String>();
#foreach($prop in $type.classProperties)
       raw.add(${prop.nameUpper});
#if($type.superclass)
       raw.addAll(${type.superclass}.FIELDS);
#end       
#end
       FIELDS = java.util.Collections.unmodifiableSet( raw );
    }
    
    
    // Dynamic Getter/Setter
#if(!$type.superclass)
    // TODO is this searched for proxies?
    @javax.persistence.Transient
	protected java.util.Map<String, Object> _dynamicFields; 

#end
    public Object retrieve(String field) {
        if (field == null) {
            return null;
#foreach($prop in $type.classProperties)
        } else if (field.equals(${prop.nameUpper})) { // TODO use == here first??
            return get${prop.nameCapped}();
#end
        } else {
#if($type.superclass)
            return super.retrieve(field);
#else
            if (_dynamicFields != null) {
                return _dynamicFields.get(field);
            }
            return null;
#end            
        }
    }
    
	@SuppressWarnings("unchecked")
    public void putAt(String field, Object value)
    {
        if (field == null) {
            return;
#foreach($prop in $type.classProperties)
        } else if (field.equals(${prop.nameUpper})) {
            set${prop.nameCapped}((${prop.fieldType})value);
#end
        } else {
#if($type.superclass)
            super.putAt(field,value);
#else            
            if (_dynamicFields == null) {
                _dynamicFields = new java.util.HashMap<String, Object>();
            }
            _dynamicFields.put(field,value);
#end            
        }
    }

#if(!$type.superclass)
    @javax.persistence.Transient
    protected boolean _loaded = true;

    public boolean isLoaded() {
        return _loaded;
    }

    protected void errorIfUnloaded() {
        if ( ! _loaded ) {
            throw new IllegalStateException("Object unloaded:"+this);
        }
    }
    
#end
    
    public void unload() {
        _loaded = false;
#foreach($prop in $type.classProperties)
        this.$prop.name = null;
#end
#if($type.superclass)
        super.unload();
#end
    }
    
#if(!$type.superclass)
    @javax.persistence.Transient
    private transient ome.model.internal.GraphHolder _graphHolder;
    
    public final ome.model.internal.GraphHolder getGraphHolder()
    {
        if (_graphHolder == null)
            _graphHolder = new ome.model.internal.GraphHolder();
        return _graphHolder;
    }
#end

    // SERIALIZATION
    /** the serialVersionID constant is set by objects.vm */
    private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException
    {
        s.defaultReadObject();  
    }

    protected void preGetter( String field ) {
        errorIfUnloaded();
    }

    protected void preSetter( String field, Object value ) {
        errorIfUnloaded();
    }

    protected void throwNullCollectionException(String propertyName) {
        throw new ApiUsageException(
            "Error updating collection:" + propertyName +"\n"+
            "Collection is currently null. This can be seen\n"+
            "by testing \"sizeOf"+ propertyName +" < 0\". This implies\n"+
            "that this collection was unloaded. Please refresh this object\n"+
            "in order to update this collection.\n"
            );
    }

#######################################################
##
## Link Type Property code
##
#if( $type.class.name.equals("ome.dsl.LinkType"))
#foreach( $prop in $type.classProperties)
#if($prop.class.name == "ome.dsl.LinkParent")
#set( $parent = ${prop.type} )
#elseif($prop.class.name == "ome.dsl.LinkChild")
#set( $child = ${prop.type} )
#end
#end
    public void link($parent parent, $child child) {
        setParent( parent );
        setChild( child );
    }

    public $parent parent() {
        return ($parent) getParent();
    }

    public $child child() {
        return ($child) getChild();
    }
	
#end
##
#######################################################

}