## SETUP
#set($cascade_settings = "lock,merge,persist,replicate,refresh,save-update")
#set($ofilter = "${type.table}_owner_filter")
#set($gfilter = "${type.table}_group_filter")
#set($efilter = "${type.table}_event_filter")
#set($pfilter = "${type.table}_perms_filter")
## No cascade on delete.
##
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" >

<hibernate-mapping>

<!--

    Each Hibernate mapping for OMERO contains a single class. The
    class is either a top-level class element or one of several
    subclass elements.

-->

#if($type.superclass)<joined-subclass
#else<class
#end
    name="${type.id}"
    table="${type.table}"
    abstract="$type.abstract"
    select-before-update="true"
    #if($type.superclass)extends="$type.superclass"#end
    >

    <!--

        The "meta" elements contain code customizations for the
        server-side (RMI/Java) mappings, including the serialVersionUID,
        constant variables, and any interfaces which should be implemented.

    -->
#if($type.abstract)
        <meta attribute="scope-class" inherit="false">public abstract</meta>
#end
        <meta attribute="extra-import">ome.model.IObject</meta>
        <meta attribute="extra-import">java.util.*</meta>
        <meta attribute="implement-equals">false</meta>
#if(!$type.global)
        <meta attribute="class-code">
          public final static String OWNER_FILTER = "${ofilter}";
          public final static String GROUP_FILTER = "${gfilter}";
          public final static String EVENT_FILTER = "${efilter}";
          public final static String PERMS_FILTER = "${pfilter}";
#foreach( $prop in $type.properties)
#if($prop.one2Many)
#set( $UC_NAME = "${prop.name.toUpperCase()}")
          public final static String OWNER_FILTER_${UC_NAME} = "${ofilter}_${UC_NAME}";
          public final static String GROUP_FILTER_${UC_NAME} = "${gfilter}_${UC_NAME}";
          public final static String EVENT_FILTER_${UC_NAME} = "${efilter}_${UC_NAME}";
          public final static String PERMS_FILTER_${UC_NAME} = "${pfilter}_${UC_NAME}";
#end
#end
        </meta>
#end
        <meta attribute="class-code">
/* These values are defined in dsl/resources/ome/dsl/mapping.vm:
 * -------------------------------------------------------------
 * Explanation of serialVersionUID ex 0000000 03 00 00 01 03 01 L;
 * 1-7   : currently unused
 * 8-9   : major part (3.x.x)
 * 10-11 : minor part (x.0.x)
 * 12-13 : patch part (x.x.0)
 * 14-15 : release type   (M)
 * 16-17 : release number (2)
 * 18-19 : increment per delta // any changes to the dsl or mapping files
 */
          private static final long serialVersionUID = 0000000030000010301L;
        </meta>
##
## INTERFACES:
## -----------
##    Can move Interfaces to a list in Type (user can add their own!)
##
#if(!$type.immutable)
        <meta attribute="implements">ome.model.IMutable</meta>
#end
#if($type.class.name.equals( "ome.dsl.EnumType" ) )
        <meta attribute="implements">ome.model.IEnum</meta>
        <meta attribute="class-code">
#set( $name_idx = ${type.id.lastIndexOf(".")} )
#set( $name_idx = ${name_idx} + 1 )
#set( $name_max = ${type.id.length()} )
#set( $name_end = ${type.id.substring($name_idx,$name_max)} )
        public $name_end (String value) {
          setValue(value);
        }
        </meta>
#end
#if( ! $type.class.name.equals("ome.dsl.LinkType"))
        <meta attribute="implements">ome.model.IObject</meta>
#else
        <meta attribute="implements">ome.model.ILink</meta>
#foreach( $prop in $type.properties)
#if($prop.class.name == "ome.dsl.LinkParent")
        <meta attribute="link-parent">$prop.type</meta>
#elseif($prop.class.name == "ome.dsl.LinkChild")
        <meta attribute="link-child">$prop.type</meta>
#end
#end
#end

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         COMMON
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
#####################################################################INHERITANCE
#if(!$type.superclass)

        <!--
            Each top-level entity contains an id field of type long.
            For all objects returned from the server, this value will
            be non-null, which doesn't necessarily hold for the other
            fields.
        -->

        <id name="id" type="java.lang.Long" column="id">
            <meta attribute="setter-scope">protected</meta>
            <meta attribute="field-description">
              The DB unique identifier for this object. You are not responsible for
              setting the id; however, it can be useful for creating "unloaded"
              versions of your objects.
            </meta>
            <generator class="sequence">
                <param name="sequence">seq_${type.table}</param>
            </generator>
        </id>

#*
#if(!$type.immutable)
        <version name="version" type="java.lang.Integer"
                column="version" unsaved-value="negative">
            <meta attribute="setter-scope">protected</meta>
            <meta attribute="field-description">
              This version number is controlled by the database for optimisitic
              locking.
            </meta>
        </version>
#end
*#

        <!--
            Every entity also contains a Detail reference, which doesn't
            refer to a separate table but rather to a collection of fields
            collected into a Hibernate "component" which is embedded in the
            object.

            HQL queries which refer to the Details component cannot directly
            fetch the entity like this:

               select o from Object join fetch o.details

            but rather each field of the Details instance must be explicitly
            joined:

               select o from Object join fetch o.details.owner

            It should also be noted that not all types have all the fields
            which are present on Details. For example,

               select e from Experimenter e join fetch e.details.owner

            will fail. Experimenter has no owner, for obvious reasons.
        -->

        <component name="details" class="ome.model.internal.Details">
            <meta attribute="field-description">
              The details of this object correspond to low-level system
              information. Owner, permissions,
            </meta>
            <!--
                Details is always guaranteed to be non-null, unless the
                user actively nulls it.
            -->
            <meta attribute="default-value">new Details()</meta>
#if(!$type.global)
            <many-to-one name="owner" class="ome.model.meta.Experimenter"
                column="owner_id" not-null="true" cascade="$cascade_settings"/>
            <many-to-one name="group" class="ome.model.meta.ExperimenterGroup"
                column="group_id" not-null="true" cascade="$cascade_settings"/>
            <!-- creationEvent is not updateable -->
            <many-to-one name="creationEvent" class="ome.model.meta.Event"
                column="creation_id" update="false"
                not-null="true" cascade="$cascade_settings"/>
#if(!$type.immutable)
            <many-to-one name="updateEvent" class="ome.model.meta.Event"
                column="update_id" update="true"
                not-null="true" cascade="$cascade_settings"/>
#end
#end

            <!--
                Permissions is a component embedded into the Details
                component. Similar rules apply as to Details, but it
                is *not* suggested that users attempt to directly
                query Permissions object as its internal state is not
                public.
            -->

            <component name="permissions" class="ome.model.internal.Permissions">
                <!--
                    Similar to Details, Permissions is always guaranteed to be
                    non-null. This is defined in ome/model/internal/Datails.java
                    but is equivalent to:
                -->
                <meta attribute="default-value">new Permissions(Permissions.DEFAULT)</meta>
                <property name="perm1" not-null="true"
                    type="long" column="permissions"/>
            </component>

            <!-- Even global objects can have external info -->
            <many-to-one name="externalInfo" class="ome.model.meta.ExternalInfo"
                column="external_id" not-null="false" unique="true"
                cascade="$cascade_settings,delete"/>

        </component>

#else ###############################################################INHERITANCE
#set($superId = ${type.typeToColumn($type.superclass)} )
        <key column="${superId}_id"/>
#end
#####################################################################INHERITANCE
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         INTERFACE-BASED
         Several properties are defined by whether or not
         the OME definition has certain interfaces.
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

#if(!$type.immutable && !$type.superclass)
        <!--
            Versions are currently disabled. See
            https://trac.openmicroscopy.org.uk/omero/ticket/118
        -->
        <property name="version" type="java.lang.Integer">
            <meta attribute="default-value">new Integer(0)</meta>
            <column name="version" default="0"/>
        </property>
#end

#if($type.named)
        <property name="name" type="java.lang.String"
                column="name" not-null="true" length="256"/>
#end

#if($type.described)
        <property name="description" type="text"
                column="description" length="256"/>
#end

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         PROPERTIES
         All properties which follow are straight-forward
         and can be understood using only the Hibernate
         documentation.
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

#foreach($prop in $type.properties)#######################################EACH
#if($prop.class.name == "ome.dsl.EntryField")#############################TYPE
## This is handled by ome/dsl/data.vm
##########################################################################TYPE
#elseif($prop.one2Many && $prop.tag)

    <!--
        one-to-one ${type.id}.${prop.name} (${prop.type})
        Represents a special tag on an item marking the item as
        default. Do not try to edit this field.
    -->
    <one-to-one
        name="${prop.name}"
        class="${prop.type}"
        property-ref="${prop.tag}Tag"
        cascade="$cascade_settings"
        lazy="false"
      >
      <meta attribute="scope-set">protected</meta>
      <formula>'true'</formula>
      <formula>id</formula>
    </one-to-one>

###########################################################################TYPE
#elseif($prop.one2Many)
#set( $UC_NAME = "${prop.name.toUpperCase()}")
#if($prop.ordered) ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ORDERED

    <!--
        one-to-many List ${type.id}.${prop.name} (${prop.type})
        Values are indexed by the column "index" on ${prop.type}
    -->
    <list
        name="${prop.name}"
        lazy="true"
        cascade="$cascade_settings">
        <key column="${prop.foreignKey}" not-null="${prop.required}"/>
        <list-index column="index"/>
        <one-to-many class="${prop.type}"/>
#if(!$type.global)
        <filter name="securityFilter"/>
        <filter name="${ofilter}_${UC_NAME}" condition=":ownerId = owner_id"/>
        <filter name="${gfilter}_${UC_NAME}" condition=":groupId = group_id"/>
        <filter name="${efilter}_${UC_NAME}" condition=":eventId = event_id"/>
        <filter name="${pfilter}_${UC_NAME}" condition=":permsStr = permissions"/>
#end
    </list>

#else ## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ORDERED

    <!--
        one-to-many Set ${type.id}.${prop.name} (${prop.type})
    -->
    <set
        name="${prop.name}"
        lazy="true"
        inverse="true"
#if($prop.class.name == "ome.dsl.ChildLink" )
        cascade="all-delete-orphan">
        <meta attribute="link-add-method">${prop.target}</meta>
        <meta attribute="link-add-order">this,addition</meta>
        <meta attribute="link-add-next">parent</meta>
        <meta attribute="link-add-other">child</meta>
        <meta attribute="link-add-bidir">${prop.bidirectional}</meta>
#elseif($prop.class.name == "ome.dsl.ParentLink")
        cascade="all-delete-orphan">
        <meta attribute="link-add-method">${prop.target}</meta>
        <meta attribute="link-add-order">addition,this</meta>
        <meta attribute="link-add-next">child</meta>
        <meta attribute="link-add-other">parent</meta>
        <meta attribute="link-add-bidir">${prop.bidirectional}</meta>
#else
        cascade="$cascade_settings">
        <meta attribute="set-add-method">${prop.inverse}</meta>
#end
        <key column="${prop.foreignKey}" not-null="${prop.required}"/>
        <one-to-many class="${prop.type}"/>
#if( !$type.global )
        <filter name="securityFilter"/>
        <filter name="${ofilter}_${UC_NAME}" condition=":ownerId = owner_id"/>
        <filter name="${gfilter}_${UC_NAME}" condition=":groupId = group_id"/>
        <filter name="${efilter}_${UC_NAME}" condition=":eventId = event_id"/>
        <filter name="${pfilter}_${UC_NAME}" condition=":permsStr = permissions"/>
#end
    </set>

#end## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ORDERED
#elseif($prop.foreignKey)## REGULAR M-1 ##################################TYPE

#if($prop.tag)
    <!--
        Properties defines a wrapper around the many-to-one
        to mark a member of the many-to-one as "default".
        Note: This will change in future versions.
    -->
    <properties name="${prop.tag}Tag">
    <property name="${prop.tag}" type="java.lang.Boolean"/>
#end
    <!--
        many-to-one field ${type.id}.${prop.name} (${prop.type})
    -->
    <many-to-one
        name="${prop.name}"
        class="${prop.type}"
        column="${prop.name}"
        not-null="${prop.required}"
        unique="${prop.unique}"
        cascade="$cascade_settings"
        insert="${prop.insert}"
        update="${prop.update}"
     >
#if($prop.class.name == "ome.dsl.LinkParent" || $prop.class.name == "ome.dsl.LinkChild")
           <meta attribute="property-type">IObject</meta>
#elseif($prop.inverse && $prop.tag)
           <meta attribute="WORKAROUND">${prop.inverse}</meta>
#elseif($prop.inverse)
           <meta attribute="fkInverse">${prop.inverse}</meta>
#end
     </many-to-one>
#if($prop.tag)
     </properties>
#end

#else## REGULAR PROPERTY #################################################TYPE

    <!-- 
        Simple field ${type.id}.${prop.name} (${prop.type}) 
    -->
    <property name="${prop.name}" type="${prop.type}"
        not-null="${prop.required}" unique="${prop.unique}"
        update="${prop.update}">
        <column name="${prop.name}"
##
## ticket:803 We are catching all floats and mapping them in the datasbase to
## double precision columns to prevent underflows. 
##
#if($prop.type.equals("java.lang.Float"))
            sql-type="double precision"
#end
        />
     </property>

#end
#end #######################################################################EACH

#if(!$type.superclass)
#if(!$type.global)
    <!-- See the comments on filters below -->
    <filter name="${ofilter}" condition=":ownerId = owner_id"/>
    <filter name="${gfilter}" condition=":groupId = group_id"/>
    <filter name="${efilter}" condition=":eventId = event_id"/>
    <filter name="${pfilter}" condition=":permsStr = permissions"/>
    <filter name="securityFilter"/>
#end
</class>
#else</joined-subclass>
#end

    <!--
        These filter definitions are used by the security system
        to eliminate non-readable objects from queries. The regular
        user does not need to worry about them, as they will be
        injected directly into the SQL (not HQL)
    -->

#if(!$type.superclass && !$type.global)
    <filter-def name="${ofilter}">
      <filter-param type="java.lang.Long" name="ownerId"/>
    </filter-def>

    <filter-def name="${gfilter}">
      <filter-param type="java.lang.Long" name="groupId"/>
    </filter-def>

    <filter-def name="${efilter}">
      <filter-param type="java.lang.Long" name="eventId"/>
    </filter-def>

    <filter-def name="${pfilter}">
      <filter-param type="java.lang.String" name="permsStr"/>
    </filter-def>

#foreach( $prop in $type.properties )
#if($prop.one2Many)
#set( $UC_NAME = "${prop.name.toUpperCase()}")
    <filter-def name="${ofilter}_${UC_NAME}">
      <filter-param type="java.lang.Long" name="ownerId"/>
    </filter-def>

    <filter-def name="${gfilter}_${UC_NAME}">
      <filter-param type="java.lang.Long" name="groupId"/>
    </filter-def>

    <filter-def name="${efilter}_${UC_NAME}">
      <filter-param type="java.lang.Long" name="eventId"/>
    </filter-def>

    <filter-def name="${pfilter}_${UC_NAME}">
      <filter-param type="java.lang.String" name="permsStr"/>
    </filter-def>
#end
#end
#end

</hibernate-mapping>
