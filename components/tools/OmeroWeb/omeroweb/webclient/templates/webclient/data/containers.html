{% extends "webclient/base/base_container.html" %}
{% load i18n %}


{% comment %}
<!--
  Copyright (C) 2011-2014 University of Dundee & Open Microscopy Environment.
  All rights reserved.

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as
  published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
{% endcomment %}

{% comment %}
<!--
  This page is the 'home page' of the 3-column data layout for webclient.
  It loads the tree in the left panel. This is then used to load data into the middle and right panels (via AJAX)
  Plugins for the centre or right panels add themselves as selection listeners to the tree.
-->
{% endcomment %}
{% block link %}
    {{ block.super }}
    <link rel="stylesheet" href="{% static "webgateway/css/ome.jstree_theme.css" %}" type="text/css" />
{% endblock %}

{% block script %}
    {{ block.super }}
    <script type="text/javascript" src="{% static "3rdparty/jquery.jstree/jstree.js" %}"></script>
    <script type="text/javascript" src="{% static "webclient/javascript/jquery.jstree.locate_plugin.js" %}"></script>
    <script type="text/javascript" src="{% static "webclient/javascript/jquery.jstree.conditionalselect_plugin.js" %}"></script>
    <script type="text/javascript" src="{% static "webclient/javascript/jquery.jstree.pagination_plugin.js" %}"></script>
    <script type="text/javascript" src="{% static "webclient/javascript/jquery.jstree.fields_plugin.js" %}"></script>
    <script type="text/javascript" src="{% static "webclient/javascript/jquery.jstree.omecut_plugin.js" %}"></script>
    <script type="text/javascript" src="{% static "webclient/javascript/jquery.jstree.ometools_plugin.js" %}"></script>
   <script type="text/javascript" src="{% static "webclient/javascript/jquery.jstree.childcount_plugin.js" %}"></script>

    <!-- set-up jstree etc -->
    <script type="text/javascript">

    // Variable to store selection data when using jstree refresh
    var refreshPathsReverse = [];

    // Variable to enable resetting of the reload central panel timeout
    // var centreReloadTimeout = false;
    // function centreReload(event, data) {

    //     if (centreReloadTimeout) {
    //         window.clearTimeout(centreReloadTimeout);
    //     }

    //     centreReloadTimeout = window.setTimeout(function() {
    //         // Update the central panel
    //         update_thumbnails_panel(event, data);
    //         centreReloadTimeout = false;
    //     }, 200);
    // }

    var getURLParameter = function(key) {
        /* Return single value for parameter with specified key
         * Does not handle multi-value parameters
         * Returns false if there are no parameters or it is not present
        */

        // If there are no parameters, just return false
        if (window.location.search.length == 0) {
            return false;
        }

        // Remove the leading '?'
        var search = window.location.search.substring(1);

        // Break them up
        var searchParams = search.split('&');

        for (var i = 0; i < searchParams.length; i++) {
            var paramSplit = searchParams[i].split('=');
            if (paramSplit[0] === key) {
                return paramSplit[1]
            }
        }
        return false;
    }

    var updateParentRemoveNode = function(inst, node, parent) {
        /* Update any other instances of the parent of this node to remove it
         * Also Based on if the parent of this node has any children
         * remaining, update the parental status of matching parents
        */

        // Get any other instances of the parent
        var parentKey = inst.locate_key(parent);
        var parentNodes = inst.locate_node(parentKey);
        // Get the parentNodeIds to easily check set membership
        var parentNodeIds = [];
        $.each(parentNodes, function(index, parentNode) {
             parentNodeIds.push(parentNode.id);
        });
        // Determine if this parent now has no children
        var parentChildless = !inst.is_parent(parent);

        // For performance reasons it is quicker to look for the nodes and check
        // their parents than to look for the parents and scan through all
        // their children
        var nodeKey = inst.locate_key(node);
        var nodeNodes = inst.locate_node(nodeKey);

        var updateParentRemoveNodes = [];
        $.each(nodeNodes, function(index, nodeNode) {
            // Discount the original node as jstree is removing that
            if (nodeNode.id === node.id) {
                return true;
            }

            // Discount any nodes that do not have one of the predetermined parents
            if ($.inArray(inst.get_parent(nodeNode), parentNodeIds) === -1) {
                return true;
            }

            // The remaining are children of identical parents and should
            // be removed
            updateParentRemoveNodes.push(nodeNode);
        });

        // Actually do the remove
        inst.delete_node(updateParentRemoveNodes);

        // If the parent is now childless it is also necessary to check
        // for any identical parent containers that are marked as expandable
        // which has ceased to be the case
        $.each(parentNodes, function(index, parentNode) {
            // Discount the original parent as jstree is handling that
            if (parentNode.id === parent.id) {
                return true;
            }

            if (parentChildless) {
                if (!inst.is_loaded(parentNode)) {
                    // Remove the offer of expansion, this is denoted by a node which is
                    // loaded, but has zero children
                    parentNode.state.loaded = true;
                    inst.redraw_node(parentNode);
                }
            }

            // Update the child count (override the childcount because it may not be
            // loaded and will thus always have no count)
            OME.updateNodeChildCount(inst, parentNode, parent.children.length);
        });


    };

    var updateParentInsertNode = function(inst, node, parent, position) {
        /* Update any other instances of the parent with the new node
         *
        */

        // Get any other instances of the parent
        var parentKey = inst.locate_key(parent);
        var parentNodes = inst.locate_node(parentKey);
        var oldParent = inst.get_node(inst.get_parent(node));

        $.each(parentNodes, function(index, parentNode) {
             // Discount the original parent as jstree is inserting that
             if (parentNode.id === parent.id) {
                // Continue
                return true;
             }

            if ((inst.is_loaded(parentNode) && inst.is_parent(parentNode)) ||
                (inst.is_loaded(parentNode) && inst.is_open(parentNode))) {
                // Create a new node to match the other examples with
                // data from the old
                var new_node_data = {
                    'data': {'id': node.data.obj.id, 'obj': node.data.obj},
                    'text': node.text,
                    'type': node.type,
                    // If it has children, we wish it to be loadable, but not loaded
                    // so just give it boolean instead of actual nodes
                    'children': inst.is_parent(node),
                    'li_attr': {
                        'class': node.type,
                        'data-id': node.data.obj.id
                    }
                };
                inst.create_node(parentNode, new_node_data, position);
            // An empty container
            } else if (!inst.is_parent(parentNode) && inst.is_loaded(parentNode)) {
                // Change the node to offer expansion
                parentNode.state.loaded = false;
                // Close the node
                inst.redraw_node(parentNode);
            }

            // Update the child count (override the childcount because it may not be
            // loaded and will thus always have no count)
            OME.updateNodeChildCount(inst, parentNode, oldParent.children.length);
        });
    };

    var removeDuplicateNodes = function(inst, node) {
        /**
         * Removes all duplicates of a node throughout the tree.
         * For use mainly when something is truly deleted as opposed to
         * unlinked
        */

        var nodeKey = inst.locate_key(node);
        var nodeNodes = inst.locate_node(nodeKey);

        $.each(nodeNodes, function(index, nodeNode) {
            // Update the parent count
            var parent = inst.get_node(inst.get_parent(nodeNode));
            var count = 0;
            if (parent.children) {
                count = parent.children.length;
            }
            OME.updateNodeChildCount(inst, parent, count);
            // Actually delete the node
            inst.delete_node(nodeNode);
        });
    };

    if (typeof OME === "undefined") { OME={}; }
        OME.handleChgrp = function(gid, gname, node) {
            var $chgrpform = $("#chgrp-form");
            $chgrpform.dialog( "option" , "title" ,"Move to Group: "+ gname);
            $chgrpform.dialog('open');
            // Add group & selected items to chgrp form
            $('input.removeMe', $chgrpform).remove();   // cleanup (horrible!)
            $("<input name='group_id' value='"+ gid +"'/>")
                .appendTo($chgrpform).addClass('removeMe').hide();
            var selobjs = OME.get_tree_selection().split("&");  // E.g. Image=1,2&Dataset=3
            for (var i=0;i<selobjs.length;i++) {
                var dtype = selobjs[i].split("=")[0],
                    dids = selobjs[i].split("=")[1];
                $("<input name='"+ dtype +"' value='"+ dids +"'/>")
                    .appendTo($chgrpform).addClass('removeMe').hide();
            }

            var chgrp_target_url = "{% url 'webindex' %}load_chgrp_target/"+gid;
            var chgrp_type = node.type;
            var target_type;

            if (chgrp_type == "dataset") target_type = "project";
            else if (chgrp_type == "image") target_type = "dataset";
            else if (chgrp_type == "plate") target_type = "screen";
            chgrp_target_url += "/"+target_type+"/";

            if (chgrp_type == "project" || chgrp_type == "screen") {
                $("#move_group_tree").html("<h1>"+ chgrp_type.capitalize() +" will be moved to group: " + gname +"</h1>");
            } else {
                // we load a tree - then give it basic selection / expansion behaviour. jsTree would have been overkill!?
                $("#move_group_tree").load(chgrp_target_url, function(){
                    var node_click = function(){
                        $("#move_group_tree a").removeClass("jstree-clicked");
                        // only allow selection of correct nodes
                        if ($(this).parent().attr('rel') == target_type) {
                            $("a" ,$(this).parent()).addClass("jstree-clicked");
                        }
                        // toggle any children
                        $("ul" ,$(this).parent()).toggle();
                    };
                    $("#move_group_tree a").click(node_click);
                    $("#move_group_tree ins").click(node_click);
                });
            }

            // Check if chgrp will attempt to Split a Fileset. Hidden until user hits 'OK'
            $("#move_group_tree").hide();               // hide tree while we wait...
            // This selection was being saved so that it could be restored if the user cancels
            // the chgrp action. The reason it might have changed is that if this is a multi-image
            // fileset then all of those will have been selected when trying to chgrp.
            // TODO Undo this hack to save selected if we can properly fix this behaviour

            $.get("{% url 'fileset_check' 'chgrp' %}?" + OME.get_tree_selection(), function(html){
                if($('div.split_fileset', html).length > 0) {
                    $(html).appendTo($chgrpform)
                    $('.chgrp_confirm_dialog .ui-dialog-buttonset button:nth-child(1) span').text("Move All");
                    var filesetId = $('input[name="fileset"]', html).val();     // TODO - handle > 1 filesetId
                    if (chgrp_type == "image") {
                        // Changing the selection really makes no sense as it can't be used for anything useful
                        // Instead the chgrp can just clean up after itself by unlinking correctly.
                        // OME.select_fileset_images(filesetId);
                    }
                } else {
                    $("#move_group_tree").show();
                }
            });
        }

        OME.handleNewContainer = function(container_type) {

            $("#new_container_type").text(container_type.capitalize());
            var $f = $("#new-container-form");
            var new_container_name = $("input[name='name']", $f).val("");     // clear fields
            var new_container_desc = $("textarea[name='description']", $f).val("");
            $("#new-container-form").dialog('open');
        }

        OME.handleDelete = function() {
            var datatree = $.jstree.reference($('#dataTree'));
            var selected = datatree.get_selected(true);

            var del_form = $( "#delete-dialog-form" );
            del_form.dialog( "open" )
                .removeData("clicked_button");
            // clear previous stuff from form
            $.removeData(del_form, "clicked_button");
            $("#delete_contents_form").show();
            del_form.unbind("dialogclose");
            del_form.find("input[type='checkbox']").prop('checked', false);

            // set up form - process all the objects for data-types and children
            var ajax_data = new Array();
            var askDeleteContents = false;
            var dtypes = {};
            // Parent to select after deletion
            var firstParent = datatree.get_node(datatree.get_parent(selected[0]));

            var disabledNodes = [];

            function traverse(state) {
                // Check if this state is one that we are looking for
                var n = datatree.get_node(state);
                disabledNodes.push(n);

                if (n.children) {
                    $.each(n.children, function(index, child) {
                         traverse(child);
                    });
                }
                datatree.disable_node(n);

            }

            $.each(selected, function(index, node) {
                // Add the nodes that are to be deleted
                ajax_data.push(node.type + '=' + node.data.obj.id);
                // What types are being deleted and how many (for pluralization)
                var dtype = node.type;
                if (dtype in dtypes) {
                    dtypes[dtype] += 1;
                } else {
                    dtypes[dtype] = 1;
                }
                // If the node type is not 'image' then ask about deleting contents
                if (!askDeleteContents && node.type != 'image') {
                    askDeleteContents = true;
                }

                // Disable the nodes marked for deletion
                // Record them so they can easily be removed/re-enabled later
                disabledNodes.push(node);
                if (node.children) {
                    $.each(node.children, function(index, child) {
                         traverse(child);
                    });
                }
                datatree.disable_node(node);
            });

            var type_strings = [];
            for (var key in dtypes) {
                type_strings.push(key.capitalize() + (dtypes[key]>1 && "s" || ""));
            }
            var type_str = type_strings.join(" & ");    // For delete dialog: E.g. 'Project & Datasets'
            $("#delete_type").text(type_str);
            if (!askDeleteContents) $("#delete_contents_form").hide();  // don't ask about deleting contents

            // callback when delete dialog is closed
            del_form.bind("dialogclose", function(event, ui) {
                if (del_form.data("clicked_button") == "Yes") {
                    var delete_anns = $("#delete_anns").prop('checked');
                    var delete_content = true;      // $("#delete_content").prop('checked');
                    if (delete_content) ajax_data[ajax_data.length] = 'child=on';
                    if (delete_anns) ajax_data[ajax_data.length] = 'anns=on';
                    var url = '{% url 'manage_action_containers' "deletemany" %}';

                    $.ajax({
                        url: url,
                        data : ajax_data.join("&"),
                        dataType: "json",
                        type: "POST",
                        success: function(r){
                            //TODO Makeshift error response should probably be removed?
                            if(eval(r.bad)) {
                                $.each(disabledNodes, function(index, node) {
                                     datatree.enable_node(node);
                                });
                                alert(r.errs);
                              } else {
                                    // Update the central panel in case delete removes an icon
                                    $.each(selected, function(index, node) {
                                        var e = {'type': 'delete_node'}
                                        var data = {'node': node,
                                                    'old_parent': firstParent};
                                        update_thumbnails_panel(e, data);
                                    });


                                    datatree.delete_node(selected);

                                    // Update the central panel with new selection
                                    datatree.deselect_all();
                                    datatree.select_node(firstParent);

                                    $.each(disabledNodes, function(index, node) {
                                        //TODO Make use of server calculated update like chgrp?
                                        updateParentRemoveNode(datatree, node, firstParent);
                                        removeDuplicateNodes(datatree, node);
                                    });

                                    OME.refreshActivities();
                              }
                        },
                        error: function(response) {
                            $.each(disabledNodes, function(index, node) {
                                 datatree.enable_node(node);
                            });
                            alert("Internal server error. Cannot remove object.");
                        }
                    });
                } else {
                    // Cancelled, re-enable nodes
                    $.each(disabledNodes, function(index, node) {
                         datatree.enable_node(node);
                    });

                }
            });

            // Check if delete will attempt to partially delete a Fileset.
            var $deleteYesBtn = $('.delete_confirm_dialog .ui-dialog-buttonset button:nth-child(1)'),
                $deleteNoBtn = $('.delete_confirm_dialog .ui-dialog-buttonset button:nth-child(2) span');
            $.get("{% url 'fileset_check' 'delete' %}?" + OME.get_tree_selection(), function(html){
                if($('div.split_fileset', html).length > 0) {
                    var $del_form_content = del_form.children().hide();
                    del_form.append(html);
                    $deleteYesBtn.hide();
                    $deleteNoBtn.text("Cancel");
                    // On dialog close, clean-up what we changed above
                    del_form.bind("dialogclose", function(event, ui) {
                        $deleteYesBtn.show();
                        $deleteNoBtn.text("No");
                        $("#chgrp_split_filesets", del_form).remove();
                        $del_form_content.show();
                    });
                }
            });
        }

        // Call this when a parent child count may have changed
        OME.updateNodeChildCount = function(tree, parent, override_count) {
            var node = tree.get_node(parent);
            var count;
            if (override_count) {
                count = override_count;
            } else {
                count = node.children.length;
            }
            // Restrict this to projects, datasets, screens and plates
            if (node.type === 'project' ||
                node.type === 'dataset' ||
                node.type === 'screen' ||
                node.type === 'plate') {

                node.data.obj.childCount = count;
                tree.redraw_node(node, false, false);
            }
        };

        function enableToolbarButton(name, enabled) {
            if (enabled) {
                $('input#'+name+'Button').removeClass('button-disabled').prop('disabled', false);
            } else {
                $('input#'+name+'Button').addClass('button-disabled').prop('disabled', true);
            }
        };

        function buttonsShowHide(selected, inst) {
            // Disable all unless explicitly enabled below
            var toolbar_config = {
                "addproject":false,
                'adddataset':false,
                'addscreen':false,
                'copy':false,
                'cut':false,
                'paste': false,
                'delete':false,
                'basket':false
            };

            // We 'canCreate' top level items, E.g. Project, Dataset, Screen, if the current userId is self or 'All Members'
            var userId = {{ ome.user_id }},
                canCreate = (userId === {{ ome.user.id }} || userId === -1);

            // These nodes can be Orphans, so creation is not selection-specific
            if (canCreate) {
                toolbar_config["addproject"] = true;
                toolbar_config["adddataset"] = true;
                toolbar_config['addscreen'] = true;
            }
            if(selected.length > 0) {

                // If the current selection(s) can be deleted
                // TODO Admin will have delete permissions on user
                // probably they should not be able to delete the
                // user from there
                if(OME.nodeHasPermission(selected, 'canDelete', {{ active_group.id }})) {
                    toolbar_config['delete'] = true;
                }

                // Only allow paste if there is a single selection and there is
                // something to paste
                if(selected.length == 1 && inst.can_paste()) {
                    // Check if the target is a suitable container for pasteing it
                    var buffer = inst.get_buffer();
                    $.each(buffer.node, function(index, node) {
                        // Run the standard jstree check to determine if paste is allowed as if using
                        // drag'n'drop.
                        if (inst.check(buffer.mode, node, selected[0], 0)) {
                            toolbar_config['paste'] = true;
                        } else {
                            // Break out of $.each as if one item can't paste, we can't paste
                            return false;
                        }
                    });

                }

                // Only allow copy/cut if the selected item(s) are elligible. This uses the slightly
                // confusingly named 'is_draggable' which is part of the drag'n'drop plugin
                // which in turn uses a jstree node type property 'draggable'
                // It also checks it the selected nodes can be linked
                if(inst.settings.dnd.is_draggable(selected)) {
                    toolbar_config['copy'] = true;
                    toolbar_config['cut'] = true;
                }

                // Only images can be added to a basket and only if they all are
                toolbar_config['basket'] = true;
                $.each(selected, function(index, node) {
                    if (node.type != 'image') {
                        toolbar_config['basket'] = false;
                        // Break out of $.each
                        return false;
                    }
                });

            }

            for (var btnName in toolbar_config) {
                enableToolbarButton(btnName, toolbar_config[btnName]);
            }
        };

        function linkNode(inst, node, parent) {

            var payload = {
                'parent_id': parent.data.obj.id,
                'parent_type': parent.type,
                'child_id': node.data.obj.id,
                'child_type': node.type
            };

            // Return a promise
            return $.ajax({
                url: "{% url 'api_links' %}",
                type: 'POST',
                data: JSON.stringify(payload),
                dataType: 'json'
            });

        };

        function unlinkNode(inst, node, parent, callback) {
            var payload = {
                'parent_id': parent.data.obj.id,
                'parent_type': parent.type,
                'child_id': node.data.obj.id,
                'child_type': node.type
            };

            // Return a promise
            return $.ajax({
                url: "{% url 'api_links' %}",
                type: 'DELETE',
                data: JSON.stringify(payload),
                dataType: 'json'
            });



        };

        // Remove duplicate nodes, normally as a result of copy_node
        // or move_node
        function removeDuplicate(inst, node, parentId) {
            var parent = inst.get_node(parentId);
            $.each(parent.children, function(index, childId) {
                var child = inst.get_node(childId);
                if (child.type === node.type &&
                    child.data.obj.id === node.data.obj.id &&
                    child.id != node.id) {
                    inst.delete_node(child);
                    // Break out of $.each
                    return false;
                }
            });
        };

        // Stuff to do on load...
        $(function()
            {
                var copy_paste_rdef_url = "{% url 'webgateway.views.copy_image_rdef_json' %}",
                    apply_owners_rdef_url = "{% url 'reset_owners_rdef_json' %}",
                    reset_rdef_json = "{% url 'reset_rdef_json' %}";

                // We truncate images when the left panel resizes...
                $("#left_panel").on('resize', OME.truncateNames);
                // and also when we load new data in the tree
                // TODO Is load_node correct? Maybe now it is when they have been drawn
                // or if it is going to be static, could handle in the convert function
                $("#dataTree").on('load_node.jstree', function() {
                    // wait for images to render, then truncate:
                    setTimeout(OME.truncateNames, 30);
                });

                // Copy the selected Image ID to the 'session' (right-click menu only allows this on 'image')
                var copyRenderingSettings = function(selected) {
                    if (selected.length == 1) {
                        var imageId = selected[0].data.obj.id;
                        $.getJSON(copy_paste_rdef_url + "?fromid=" + imageId);
                    }
                }

                // Paste settings from 'session' to selected Objects
                var pasteRenderingSettings = function(selected, owner, reset) {
                    var ids = [];
                    var rdef_url = copy_paste_rdef_url;

                    // Get the type of object having rendering settings applied
                    var type = selected[0].type;

                    if (owner) {
                        rdef_url = apply_owners_rdef_url;
                    } else if (reset) {
                        rdef_url = reset_rdef_json;
                    }

                    // Get list of ids to be updated
                    $.each(selected, function(index, node) {
                         ids.push(node.data.obj.id);
                    });

                    rdef_url += "?toids=" + ids.join("&toids=");
                    if (type === 'dataset' || type === 'plate' || type === 'acquisition') {
                        rdef_url += '&to_type='+ type;
                    }

                    var confirmMsg = "This will save new rendering settings to " +
                        selected.length + " " + type +
                        (selected.length > 1 ? "s" : "") + ".<br> This cannot be undone.";

                    var rdef_confirm_dialog = OME.confirm_dialog(
                        confirmMsg,
                        function() {
                            var clicked_button_text = rdef_confirm_dialog.data("clicked_button");
                            if (clicked_button_text === "OK") {
                                $.getJSON(rdef_url, function(data){
                                    // update thumbnails
                                    OME.refreshThumbnails();
                                });
                            }
                        },
                        "Change Rendering Settings?",
                        ["OK", "Cancel"],
                        350,
                        175
                    );
                }

                var applyOwnerRenderingSettings = function(selected) {
                    pasteRenderingSettings(selected, true);
                };

                var resetRenderingSettings = function(selected) {
                    pasteRenderingSettings(selected, false, true);
                };

                // Handle creation of new Project, Dataset or Screen...
                $("#new-container-form").dialog({
                    autoOpen: false,
                    resizable: true,
                    height: 280,
                    width:420,
                    modal: true,
                    buttons: {
                        "OK": function() {
                             createNewContainer();
                             $( this ).dialog( "close" );
                        },
                        "Cancel": function() {
                            $( this ).dialog( "close" );
                        }
                    }
                });

                // same code is called from closing dialog or 'submit' of form
                $("#new-container-form").submit(function() {
                    $("#new-container-form").dialog( "close" );
                    createNewContainer();
                    return false;
                });

                var createNewContainer = function() {
                    var cont_type = $("#new_container_type").text().toLowerCase();  // E.g. 'project'
                    var $f = $("#new-container-form");
                    var new_container_name = $("input[name='name']", $f).val();
                    var new_container_desc = $("textarea[name='description']", $f).val();
                    if ($.trim(new_container_name).length == 0) {
                        alert("Please enter a Name");
                        return;
                    }

                    // If images under orphaned are selected, note IDs (for adding to new dataset)
                    var inst = $.jstree.reference('#dataTree');
                    var selected = inst.get_selected(true);
                    // TODO Only keeping img_ids because it is simpler to POST the data using that
                    // Can be removed when updating the ajax call
                    var img_ids = [];
                    var orphaned_image_nodes = [];

                    $.each(selected, function(index, node) {
                         if (node.type === 'image' &&
                             inst.get_node(inst.get_parent(node)).type === 'orphaned' &&
                             OME.nodeHasPermission(node, 'canLink', {{ active_group.id }})) {
                            img_ids.push(node.data.obj.id);
                            orphaned_image_nodes.push(node);
                         }
                    });

                    // If a project is selected, create dataset under it
                    var url, position = 0;
                    var parent = false;
                    if(selected.length == 1 && selected[0].type === 'project' && cont_type == 'dataset') {
                        url = '{% url 'manage_action_containers' "addnewcontainer" %}project/'+selected[0].data.obj.id+'/';
                        parent = selected[0];
                    // otherwise create an orphan of "folder_type" ('project', 'dataset', 'screen' etc. )
                    } else {
                        url = '{% url 'manage_action_containers' "addnewcontainer" %}';
                        // Make sure top level objects get added to jsTree root (current selected may be project, dataset, image or screen)
                        var root = inst.get_node('#');
                        $.each(root.children, function(index, id) {
                            var node = inst.get_node(id);
                             if (node.type === 'experimenter' && node.data.obj.id === {{ ome.user_id }}) {
                                parent = node;
                                // Break out of each
                                return false;
                             }
                        });

                    }

                    var ajax_data = {
                            "name" : new_container_name,
                            "folder_type" : cont_type,
                            "description" : new_container_desc
                        }
                    if (img_ids.length > 0){
                        ajax_data['img_ids'] = img_ids.join(",");
                    }
                    $.ajax({
                        url: url,
                        data: ajax_data,
                        dataType: "json",
                        type: "POST",
                        success: function(r){

                            var data = {
                                'id': r['id'],
                                'isOwner': true,
                                'name': new_container_name,
                                // Is that it for perms!? Seems very limited. A dataset normally has:
                                // canEdit canAnnotate canLink canDelete canChgrp
                                'permsCss': 'canLink canDelete'
                            };

                            var node = {
                                'data': {'id': r['id'], 'obj': data},
                                'text': new_container_name + '<span class="children_count"></>',
                                'children': false,
                                'type': cont_type,
                                'li_attr': {
                                    'class': cont_type,
                                    'data-id': r['id']
                                }
                            };

                            // Create the node, move any orphans into it and select only it
                            node = JSON.parse(JSON.stringify(node));
                            inst.create_node(parent, node, 'last', function(node) {
                                if (orphaned_image_nodes.length > 0) {
                                    inst.move_node(orphaned_image_nodes, node);
                                }
                                // There is no need to update duplicates at the moment as nothing that
                                // can be created could have a duplicate to need updating
                                inst.deselect_all();
                                inst.select_node(node);
                                //TODO Scroll to new if off screen? https://github.com/vakata/jstree/issues/519
                            });
                        }
                    });
                };

                // After we edit the chgrp dialog to handle Filesets, we need to clean-up
                var resetChgrpForm = function() {
                    $('.chgrp_confirm_dialog .ui-dialog-buttonset button:nth-child(1) span').text("OK");
                    $("#move_group_tree").show();
                    $("#chgrp_split_filesets").remove();
                };

                var $chgrpform = $("#chgrp-form");
                $chgrpform.dialog({
                    dialogClass: 'chgrp_confirm_dialog',
                    autoOpen: false,
                    resizable: true,
                    height: 310,
                    width:420,
                    modal: true,
                    buttons: {
                        "OK": function() {
                            var $thisBtn = $('.chgrp_confirm_dialog .ui-dialog-buttonset button:nth-child(1) span');
                            // If we have split filesets, on the first click 'OK', we ask 'Move All'?
                            if ($("#chgrp_split_filesets .split_fileset").length > 0) {
                                if ($thisBtn.text() == 'Move All') {
                                    $("#move_group_tree").show();
                                    $("#chgrp_split_filesets").hide();
                                    $thisBtn.text('OK');
                                    return false;
                                }
                            }
                            $("#chgrp-form").submit();
                            resetChgrpForm();
                        },
                        "Cancel": function() {
                            resetChgrpForm();
                            // TODO I'm not really sure why the file selection changes to be that of the fileset?
                            // var datatree = $.jstree.reference('#dataTree');
                            // datatree.deselect_all();
                            // datatree.reselect();        // revert to previous selection
                            $( this ).dialog( "close" );
                        }
                    }
                });

                // handle chgrp
                $("#chgrp-form").ajaxForm({
                    beforeSubmit: function(data){
                        $("#chgrp-form").dialog("close");
                        var chgrp_target = $("#move_group_tree a.jstree-clicked");

                        if (chgrp_target.length == 1){
                            data.push({'name':'target_id', 'value': chgrp_target.parent().attr('id')});
                        }
                    },
                    success: function(data) {
                        var inst = $.jstree.reference('#dataTree');
                        var remove = data.update.remove;
                        var childless = data.update.childless;

                        // Find and remove
                        for (property in remove) {
                            if (remove.hasOwnProperty(property)) {
                                $.each(remove[property], function(index, id) {
                                    var removeLocated = inst.locate_node(property + '-' + id);
                                    // If some nodes were found, delete them. The most likely reason
                                    // that nodes are not found is that a delete_node in this loop
                                    // has already deleted them as they are children of another node
                                    if (removeLocated) {
                                        inst.delete_node(removeLocated);
                                    }
                                });
                            }

                        }

                        // Find and mark childless
                        for (property in childless) {
                            if (childless.hasOwnProperty(property)) {
                                $.each(childless[property], function(index, id) {
                                    var childlessLocated = inst.locate_node(property + '-' + id);
                                    // If some nodes were found, make them childless
                                    if (childlessLocated) {
                                        $.each(childlessLocated, function(index, node) {
                                            node.state.loaded = true;
                                            inst.redraw_node(node);
                                        });

                                    }
                                });
                            }

                        }

                        OME.showActivities();
                    }
                });

                // chgrp form behavior
                $("#chgrp-form .group_option").click(function(){
                    $("#chgrp-form .group_option").removeClass('selected');
                    $(this).addClass('selected');
                    $("input[type='radio']", $(this)).prop('checked', true);
                });
                $("#chgrp-form .group_option :first").click();  // select first option

                $("#delete-dialog-form").dialog({
                    dialogClass: 'delete_confirm_dialog',
                    autoOpen: false,
                    resizable: true,
                    height: 210,
                    width:420,
                    modal: true,
                    buttons: {
                        "Yes": function() {
                            $("#delete-dialog-form").data("clicked_button", "Yes");
                            $( this ).dialog( "close" );
                        },
                        "No": function() {
                            $("#delete-dialog-form").data("clicked_button", "No");
                            $( this ).dialog( "close" );
                        }
                    }
                });

                // Select jstree and then cascade handle events and setup the tree.
                var jstree = $("#dataTree")
                .on('changed.jstree', function (e, data) {
                    var inst = data.instance;
                    buttonsShowHide(inst.get_selected(true), inst);

                    // Load on selection, but not open because that breaks key navigation
                    if (data.node &&
                        inst.is_parent(data.node) &&
                        !inst.is_loaded(data.node) &&
                        !inst.is_loading(data.node)) {
                        inst.load_node(data.node);
                    }

                    OME.tree_selection_changed(data, e);
                })
                .on('copy_node.jstree', function(e, data) {
                    /**
                    * Fired when a node is copied
                    * Updates the server, adding the new link
                    */
                    var inst = data.instance;

                    // The data is not cloned when the node is copied, do that manually
                    data.node.data = JSON.parse(JSON.stringify(data.original.data));

                    // Copy the data for any child nodes in the copy as well
                    for(var i = 0; i < data.original.children_d.length; i++) {
                        var originalData = inst.get_node(data.original.children_d[i]).data;
                        originalData = JSON.parse(JSON.stringify(originalData));
                        inst.get_node(data.node.children_d[i]).data = originalData;
                    }

                    // Remove potential duplicate node
                    removeDuplicate(inst, data.node, data.parent);

                    // Persist
                    $.when(linkNode(inst, data.node, inst.get_node(data.parent))).done(function() {
                        update_thumbnails_panel(e, data);
                    });

                    // Update the child count
                    OME.updateNodeChildCount(inst, data.parent);

                    // Add to other identical nodes as well
                    updateParentInsertNode(inst, data.node, inst.get_node(data.parent), data.position);
                })
                .on('move_node.jstree', function(e, data) {
                    /**
                    * Fired when a node is moved
                    * Updates the server, removing the old link and adding the new
                    */
                    var inst = data.instance;
                    // Remove potential duplicate node
                    removeDuplicate(inst, data.node, data.parent);

                    // trigger ome remove
                    $("body").trigger('removed_node.jstree.ome', data.node.data.obj);

                    // Persist
                    var linkPromise;
                    // If the move is orphaning an object, do not persist the link
                    if (data.parent.type !== 'experimenter' &&
                        data.parent.type !== 'orphaned') {
                        linkPromise = linkNode(inst, data.node, inst.get_node(data.parent));
                    }
                    var unlinkPromise = unlinkNode(inst, data.node, inst.get_node(data.old_parent));

                    $.when(linkPromise, unlinkPromise).done(function() {
                        update_thumbnails_panel(e, data);
                    });

                    // Add/Remove node to/from other identical nodes as well
                    updateParentInsertNode(inst, data.node, inst.get_node(data.parent), data.position);
                    updateParentRemoveNode(inst, data.node, inst.get_node(data.old_parent));

                    // Update the child counts
                    OME.updateNodeChildCount(inst, data.parent);
                    OME.updateNodeChildCount(inst, data.old_parent);

                })
                .on('delete_node.jstree', function(e, data) {
                    /**
                    * Fired when a node is deleted
                    * Simply removes the node, we do not update the server here as there
                    * is a need to delete nodes without persisting. E.g. when a dataset
                    * is updated to match another instance of itself elsewhere in the tree
                    */
                    var inst = data.instance;
                    // Update the child count
                    OME.updateNodeChildCount(inst, data.parent);
                })
                .on('create_node.jstree', function(e, data) {
                    /**
                    * Fired when a node is created
                    * Simply adds the node, we do not update the server here as there
                    * is a need to create nodes without persisting. E.g. when a dataset
                    * is updated to match another instance of itself elsewhere in the tree
                    */
                    var inst = data.instance;
                    // Update the child count
                    OME.updateNodeChildCount(inst, data.parent);
                })
                .on('loaded.jstree', function(e, data) {
                    /**
                    * Fired when the tree is loaded and ready for action
                    */

                    // If it isn't present
                    if (window.location.search.length == 0) {
                        return false;
                    }

                    // Introspect the URL to get the show parameter
                    var param = getURLParameter('show');

                    if (param) {
                        var inst = data.instance;

                        // Gather data for request
                        var paramSplit = param.split('-');

                        var payload = {};
                        payload[paramSplit[0]] = paramSplit[1];

                        // AJAX Query to get the path of the item we wish to 'show'
                        $.ajax({
                            url: '{% url 'api_paths_to_object' %}',
                            data : payload,
                            dataType: "json",
                            type: "GET",
                            success: function(json) {
                                data = json.paths;
                                // Use the open_node callback mechanism to facilitate loading the tree to the
                                // point indicated by the path, starting from the top, 'experimenter'.
                                var path = data[0];
                                var lastIndex = path.length - 1;

                                var traverse = function(index, parentNode) {
                                    // Get this path component
                                    var comp = path[index];
                                    // Get the node for this path component
                                    var node = inst.locate_node(comp.type + '-' + comp.id, parentNode)[0];

                                    // If at any point the node doesn't exist, simply give up as the path has
                                    // become invalid
                                    if (node === false) {
                                        return;
                                    }

                                    // If this is not the final path component, open it and
                                    // traverse in the callback
                                     if (index < lastIndex) {
                                        inst.open_node(node, function() {
                                            traverse(index += 1, node);
                                        })

                                    // Otherwise select it
                                     } else {
                                        // TODO Centre view on this selection
                                        inst.select_node(node);
                                     }
                                };

                                // Start traversing at the start of the path with no parent node
                                traverse(0, undefined);
                            },
                            error: function(json) {
                                console.log('failure');
                            }
                        });
                    }

                    // Update the URL to remove the parameters as they serve to preload data this one
                    // time only
                    // history.pushState({}, '', window.location.pathname);
                })
                .on("click.jstree", ".jstree-anchor", function (e) {
                    e.preventDefault();
                    var datatree = $.jstree.reference($('#dataTree'));
                    // Expand on click (not select because of key navigation)
                    if (datatree.is_parent(this)) {
                        datatree.open_node(this);
                    }
                })
                .on("dblclick.jstree", ".jstree-anchor", function (e) {
                    e.preventDefault();
                    var datatree = $.jstree.reference($('#dataTree'));
                    var node = datatree.get_node(this);
                    if (node) {
                        if (node.type === 'image') {
                            //Open the image viewer for this image
                            OME.openPopup("{% url 'web_image_viewer' 0 %}".replace('0', node.data.obj.id ));
                        }
                    }
                })
                .on('keydown.jstree', '.jstree-anchor', function (e) {
                    var datatree = $.jstree.reference($('#dataTree'));

                    switch(e.which) {
                        // Up
                        case 38:
                            e.preventDefault();
                            var prev = datatree.get_prev_dom(this);
                            if(prev && prev.length) {
                                datatree.deselect_all();
                                datatree.select_node(prev);
                            }
                            break;
                        // Down
                        case 40:
                            e.preventDefault();
                            var next = datatree.get_next_dom(this);
                            if(next && next.length) {
                                datatree.deselect_all();
                                datatree.select_node(next);
                            }
                            break;
                        // Left
                        case 37:
                            e.preventDefault();
                            if(!datatree.is_open(this)) {
                                var prev = datatree.get_prev_dom(this);
                                if(prev && prev.length) {
                                    datatree.deselect_all();
                                    datatree.select_node(prev);
                                }
                            }
                            break;
                        // Right
                        case 39:
                            e.preventDefault();
                            // opening of node is handled by jsTree, we just select...
                            if(!datatree.is_closed(this)) {
                                var next = datatree.get_next_dom(this);
                                if(next && next.length) {
                                    datatree.deselect_all();
                                    datatree.select_node(next);
                                }
                            }
                            break;
                    }

                })
                .on('refresh.jstree', function(){
                    var datatree = $.jstree.reference($('#dataTree'));

                    // Use the cached selection in refreshPathsReverse to restore the selection after refresh
                    $.each(refreshPathsReverse, function(index, refreshPathReverse) {
                        // If all parts of the path match the located node then select it
                        var locatedNodes = datatree.locate_node(refreshPathReverse[0][0] +
                                           '-' +
                                           refreshPathReverse[0][1]);
                        $.each(locatedNodes, function(index, node) {
                            var traverseNode = node;
                            var matched = true;
                            $.each(refreshPathReverse, function(index, pathComponent) {
                                if (traverseNode &&
                                    traverseNode.type === pathComponent[0] &&
                                    traverseNode.data.obj.id === pathComponent[1]) {
                                    // Update traverseNode to be its own parent
                                    traverseNode = datatree.get_node(datatree.get_parent(traverseNode));
                                } else {
                                    matched = false;
                                    // Exit refreshPathReverse each loop
                                    return false;                            }
                            });

                            if (matched) {
                                datatree.select_node(node)
                                // Exit locatedNodes each loop
                                return false;
                            }
                        });

                    });
                    // Clear refreshPathsReverse after selection has been restored
                    refreshPathsReverse = [];
                })

                // Setup jstree
                .jstree({
                    'plugins': ['types', 'contextmenu', 'dnd', 'sort', 'locate',
                                'ometools', 'conditionalselect', 'pagination', 'fields',
                                'childcount', 'omecut'],
                    // The jstree core
                    'locate' : {
                        // Returns a key for this node
                        'locate_function': function(node) {
                            // In some cases, this function is called before the data attribute exists
                            // These should be ignored, this will be called again later when it is
                            // populated.
                            if (!node.hasOwnProperty('data') ||
                                node.data === undefined ||
                                node.data === null) {
                                return false;
                            }
                            return node.type + '-' + node.data.obj.id;
                        }
                    },
                    'conditionalselect' : {
                        // Checks if a selection should be allowed
                        'conditionalselect_function': function(node) {
                            var inst = this;
                            var selected = inst.get_selected(true);
                            // As this function will previously have prevented cross-select, just
                            // check the first selection instead.
                            if (selected.length > 0 && selected[0].type !== node.type) {
                                return false;
                            }

                            // Also disallow the selection if it is a multi-select and the new target
                            // is already selected
                            var selected = inst.get_selected(true);
                            var allowSelect = true;
                            $.each(selected, function(index, sel) {
                                 if (sel.type === node.type && sel.data.obj.id === node.data.obj.id) {
                                    allowSelect = false;
                                    // Break out of each
                                    return false;
                                 }
                            });

                            return allowSelect;

                        }
                    },
                    'omecut': {
                        'path_url': '{% url 'api_paths_to_object' %}'
                    },
                    'core' : {
                        'themes': {
                            'dots': false,
                            'variant': 'ome'
                        },
                        'force_text': true,
                        'data' : {
                            // Configure URL for request
                            'url' : function(node) {
                                //TODO
                                // Get the type of the node being expanded
                                // Figure out what type of children it should have
                                // Request the list of children from that url, adding any relevant filters

                                if (node.type === 'experimenter') {
                                    return '{% url 'api_containers' %}'
                                } else if (node.type === 'project') {
                                    return '{% url 'api_datasets' %}'
                                } else if (node.type === 'dataset') {
                                    return '{% url 'api_images' %}'
                                } else if (node.type === 'screen') {
                                    return '{% url 'api_plates' %}'
                                } else if (node.type === 'plate') {
                                    return '{% url 'api_plate_acquisitions' %}'
                                } else if (node.type === 'orphaned') {
                                    return '{% url 'api_images' %}'
                                } else if (node.id === '#') {
                                    return '{% url 'api_experimenters' %}'
                                }
                            },
                            // Gather data for request
                            'data' : function(node) {

                                var payload = {};

                                // Get the data for this query
                                // Exception to this for orphans as in the case of api_images, id is a dataset
                                if (node.hasOwnProperty('data') && node.type != 'orphaned') {
                                    if (node.data.hasOwnProperty('obj')) {
                                        payload['id'] = node.data.obj.id;
                                    }
                                }
                                // Work back up the tree to obtain the id of the user we are viewing,
                                // this is useful in the case of orphaned image listing in particular.
                                // It may also be appropriate to use it to filter the queries in other
                                // places as well.
                                var inst = this;

                                // This path does not include the root node so the first entry is always
                                // the experimenter node except on inital load in which case it is false
                                var path = inst.get_path(node, false, true);
                                if (path) {
                                    payload['experimenter_id'] = inst.get_node(path[0]).data.obj.id;
                                }

                                // If this is a node which can have paged results then either specify that
                                // we want the first page or the specific page
                                if (node.type === 'dataset' || node.type === 'orphaned') {
                                    // Attempt to get the current page desired if there is one
                                    var page = inst.get_page(node);
                                    if (page) {
                                        payload['page'] = page;
                                    // Otherwise, always get page 1
                                    } else {
                                        payload['page'] = 1;
                                    }
                                }

                                // Specify that orphans are specifically sought
                                if (node.type === 'orphaned') {
                                    payload['orphaned'] = true;
                                }

                                // Always add the group_id from the current context
                                payload['group_id'] = {{ active_group.id }};


                                return payload;
                            },
                            'cache': false,

                            'error': function() {
                                // TODO What do we do now if there is an error from the REST API?
                                // Launch the Error Dialog?
                                console.log('ERROR IN AJAX');

                            },
                            // Converter is required because the JSON format being returned is not
                            // jstree specific.
                            'converters' : {
                                "text json": function (json) {
                                    var data = JSON.parse(json);
                                    var jstree_data = [];

                                    // Add experimenters to the jstree data structure
                                    if (data.hasOwnProperty('experimenters')) {
                                        $.each(data.experimenters, function(index, value) {
                                            var node = {
                                                'data': {'id': value.id, 'obj': value},
                                                'text': value.firstName + ' ' + value.lastName,
                                                'children': true,
                                                'type': 'experimenter',
                                                'state': {
                                                },
                                                'li_attr': {
                                                    'data-id': value.id
                                                }
                                            };

                                            // Add 'state' opened for the current user by default
                                            {% if active_user %}
                                                if (value.id == {{ active_user.getId }}) {
                                                    node.state['opened'] = true;
                                                }
                                            {% endif %}

                                            jstree_data.push(node);
                                        });
                                    }

                                    // Add projects to the jstree data structure
                                    if (data.hasOwnProperty('projects')) {
                                        $.each(data.projects, function(index, value) {
                                            var node = {
                                                'data': {'id': value.id, 'obj': value},
                                                'text': value.name,
                                                'children': value.childCount > 0 ? true : false,
                                                'type': 'project',
                                                'li_attr': {
                                                    'data-id': value.id
                                                }
                                            };
                                            jstree_data.push(node);
                                        });
                                    }

                                    // Add datasets to the jstree data structure
                                    if (data.hasOwnProperty('datasets')) {
                                        $.each(data.datasets, function(index, value) {
                                            var node = {
                                                'data': {'id': value.id, 'obj': value},
                                                'text': value.name,
                                                'children': value.childCount > 0 ? true : false,
                                                'type': 'dataset',
                                                'li_attr': {
                                                    'data-id': value.id
                                                }
                                            };
                                            jstree_data.push(node);
                                        });
                                    }

                                    // Add images to the jstree data structure
                                    if (data.hasOwnProperty('images')) {
                                        $.each(data.images, function(index, value) {
                                            var node = {
                                                'data': {'id': value.id, 'obj': value},
                                                'text': value.name,
                                                'children': false,
                                                'type': 'image',
                                                'li_attr': {
                                                    'data-id': value.id
                                                }
                                            };
                                            jstree_data.push(node);
                                        });
                                    }

                                    // Add screens to the jstree data structure
                                    if (data.hasOwnProperty('screens')) {
                                        $.each(data.screens, function(index, value) {
                                             var node = {
                                                'data': {'id': value.id, 'obj': value},
                                                'text': value.name,
                                                'children': value.childCount > 0 ? true : false,
                                                'type': 'screen',
                                                'li_attr': {
                                                    'data-id': value.id
                                                }
                                             };
                                             jstree_data.push(node);
                                        });
                                    }

                                    // Add plates to the jstree data structure
                                    if (data.hasOwnProperty('plates')) {
                                        $.each(data.plates, function(index, value) {
                                             var node = {
                                                'data': {'id': value.id, 'obj': value},
                                                'text': value.name,
                                                'children': value.childCount > 0 ? true : false,
                                                'type': 'plate',
                                                'li_attr': {
                                                    'data-id': value.id
                                                }
                                             };
                                             jstree_data.push(node);
                                        });
                                    }

                                    // Add plates to the jstree data structure
                                    if (data.hasOwnProperty('acquisitions')) {
                                        $.each(data.acquisitions, function(index, value) {
                                             var node = {
                                                'data': {'id': value.id, 'obj': value},
                                                'text': value.name,
                                                'children': false,
                                                'type': 'acquisition',
                                                'li_attr': {
                                                    'data-id': value.id
                                                }
                                             };
                                             jstree_data.push(node);
                                        });
                                    }

                                    if (data.hasOwnProperty('orphaned')) {
                                        var node = {
                                            'data': {'obj': data.orphaned},
                                            'text': 'Orphaned Images',
                                            'children': data.orphaned.childCount > 0 ? true : false,
                                            'type': 'orphaned'
                                        };
                                        jstree_data.push(node);
                                    }

                                    return jstree_data;
                                }

                            }
                        },
                        'check_callback': function(operation, node, node_parent, node_position, more) {
                            // Before this (and thus before the copy and the paste) the nodes children
                            // are loaded. This is important as it allows us to weed out potential
                            // conflicts in the copy, i.e. where a link to the object already exists
                            // Called once per item being moved
                            // TODO Handle case when all links were removed, they should pop up in experimenter/orphans
                            // TODO Should be impossible to delete a link from orphans
                            // TODO What about if the users moves an image/dataset to orphans/experimenter, should
                            // that remove all of its links? Or disallow?
                            var inst = $.jstree.reference(node);

                            // Sometimes '#' pops up in the destination of d'n'd, discount this
                            if (node_parent.id === '#') {
                                return false;
                            }

                            // Discount moves to a duplicate for both dnd checking and actual copy/move
                            // Also ensure sourec and destination are linkable
                            if (operation === 'copy_node' || operation === 'move_node') {
                                var oldParent = inst.get_node(node.parent)
                                if (oldParent.type === node_parent.type &&
                                    oldParent.data.obj.id === node_parent.data.obj.id) {
                                    return false;
                                }
                            }

                            // On actual copy/move allow all valid
                            if (more != undefined && more.core &&
                                (operation === 'copy_node' || operation === 'move_node')) {
                                // Check that the user has permission to list on the new parent
                                // or that their user themselves is the new parent
                                // or that their 'orphaned' directory is the new parent
                                if (!OME.nodeHasPermission(node_parent, 'canLink', {{ active_group.id }}) &&
                                    node_parent.type !== 'experimenter' &&
                                    node_parent.type !== 'orphaned' &&
                                    node_parent.data.obj.id !== {{ active_group.id }}) {
                                    return false;
                                }
                                return true;
                            // For dnd checking if it can copy/move
                            } else if (operation === 'copy_node' || operation === 'move_node') {
                                if (!OME.nodeHasPermission(node_parent, 'canLink', {{ active_group.id }})) {
                                    return false;
                                }

                                var nodeRules = inst.get_rules(node);
                                var parentRules = inst.get_rules(node_parent);
                                if (parentRules.valid_children != -1 &&
                                    parentRules.valid_children.indexOf(node.type) > -1) {
                                    return true;
                                }
                                return false;
                            }
                            // Default to allowing all operations
                            // 'copy_node', 'move_node' Handled above
                            // 'delete_node', 'rename_node': true
                            return true;
                        }
                    },
                    'types' : {
                        '#' : {
                            'valid_children': ['experimenter']
                        },
                        'default': {
                            'draggable': false
                        },
                        'experimenter': {
                            'icon' : '{% static "webclient/image/icon_user.png" %}',
                            'valid_children': ['project','dataset','screen','plate']
                        },
                        'project': {
                            'icon': '{% static "webclient/image/folder16.png" %}',
                            'valid_children': ['dataset']
                        },
                        'dataset': {
                            'icon': '{% static "webclient/image/folder_image16.png" %}',
                            'valid_children': ['image'],
                            'draggable': true
                        },
                        'image': {
                            'icon': '{% static "webclient/image/image16.png" %}',
                            'draggable': true
                        },
                        'screen': {
                            'icon': '{% static "webclient/image/folder_screen16.png" %}',
                            'valid_children': ['plate']
                        },
                        'plate': {
                            'icon': '{% static "webclient/image/folder_plate16.png" %}',
                            'valid_children': ['acquisition'],
                            'draggable': true
                        },
                        'acquisition': {
                            'icon': '{% static "webclient/image/image16.png" %}',
                        },
                        'orphaned': {
                            'icon': '{% static "webclient/image/folder_yellow16.png" %}',
                            'valid_children': ['image']
                        }

                    },
                    'dnd': {
                        'is_draggable': function(nodes) {
                            var inst = $.jstree.reference(nodes[0]);
                            // Check if the node types are draggable and the particular nodes have the
                            // 'canLink' permission. All must pass
                            for (index in nodes) {
                                if (!inst.get_rules(nodes[index]).draggable ||
                                      !OME.nodeHasPermission(nodes[index], 'canLink', {{ active_group.id }})
                                    ) {
                                    return false;
                                }
                            }
                            return true;
                        }
                    },
                    'contextmenu': {
                        // TODO This is true in the current webclient, but it seems clumsy
                        'select_node': true,
                        'show_at_node': false,
                        //TODO Convention for naming jquery objects, maybe this should be $node
                        // If that is the case, fix in other places
                        'items' : function(node){
                            var config = {};

                            config["create"] = {
                                "label" : "Create new",
                                "submenu": {
                                    "project": {
                                        "label" : "Project",
                                        "icon"  : '{% static "webclient/image/folder16.png" %}',
                                        action: function (node) {OME.handleNewContainer("project"); },
                                    },
                                    "dataset": {
                                        "label" : "Dataset",
                                        "icon"  : '{% static "webclient/image/folder_image16.png" %}',
                                        action: function (node) {OME.handleNewContainer("dataset"); },
                                      },
                                      "screen": {
                                        "label" : "Screen",
                                        "icon"  : '{% static "webclient/image/folder_screen16.png" %}',
                                        action: function (node) {OME.handleNewContainer("screen"); },
                                      }
                                }
                            };

                            config["ccp"] = {
                                "label"     : "Edit",
                                "action"    : false,
                                "submenu"   : {
                                    "cut"   :{
                                        "label" : "Cut Link",
                                        "icon"  : '{% static "webclient/image/icon_basic_cut_16.png" %}',
                                        "action": function(data) {
                                            var inst = $.jstree.reference(data.reference);
                                            var objs = inst.get_selected(true)
                                            inst.cut(objs);
                                            // Always disable paste button immediatly after using it
                                            enableToolbarButton('paste', false);
                                        }
                                    },
                                    "copy"  : {
                                        "label" : "Copy Link",
                                        "icon"  : '{% static "webclient/image/icon_basic_copy_16.png" %}',


                                        "action": function (data) {
                                            var inst = $.jstree.reference(data.reference);
                                            var objs = inst.get_selected(true)
                                            inst.copy(objs);
                                        }

                                    },
                                    "paste": {
                                        "label" : "Paste Link",
                                        "icon"  : '{% static "webclient/image/icon_basic_paste_16.png" %}',
                                        "action": function(data) {
                                            var inst = $.jstree.reference(data.reference);
                                            var obj = inst.get_node(data.reference);
                                            // Paste whatever is in the paste buffer into obj
                                            inst.paste(obj);
                                            // Always disable paste button immediatly after using it
                                            enableToolbarButton('paste', false);
                                        }
                                    }
                                }
                            };

                            config["delete"] = {
                                "label" : "Delete",
                                "icon"  : '{% static "webclient/image/icon_basic_delete_16.png" %}',
                                "action": OME.handleDelete
                            };

                            config["chgrp"] = {
                                "label" : "Move to Group...",
                                "icon"  : '{% static "webclient/image/icon_basic_user_16.png" %}',
                                "submenu"   : {
                                    {% for grp in myGroups %}
                                        {% ifnotequal grp.id active_group.id %}
                                            "menuitem{{ grp.id }}" : {
                                                "label" : "{{ grp.name }}",
                                                "icon"  : {% if grp.getDetails.getPermissions.isGroupWrite %} src="{% static 'webclient/image/group_green16.png' %}"
                                                {% else %}
                                                    {% if grp.getDetails.getPermissions.isGroupAnnotate %} src="{% static "webclient/image/group_orange16.png" %}"
                                                    {% else %}
                                                        {% if grp.details.permissions.isGroupRead %} src="{% static "webclient/image/group_red16.png" %}"
                                                        {% else %}
                                                            src="{% static "webclient/image/personal16.png" %}"
                                                        {% endif %}
                                                    {% endif %}
                                                {% endif %},
                                                "action": function(data) {
                                                    var inst = $.jstree.reference(data.reference);
                                                    var obj = inst.get_node(data.reference);
                                                    OME.handleChgrp({{ grp.id }}, "{{ grp.name }}", obj);
                                                }
                                            },
                                        {% endifnotequal %}
                                    {% endfor %}
                                }
                            };

                            config["basket"] = {
                                "label" : "Add to Basket",
                                "icon"  : '{% static "webclient/image/icon_basic_basket_16.png" %}',
                                "action": function(){
                                    var inst = $.jstree.reference('#dataTree');
                                    OME.addToBasket(inst.get_selected(), '{% url 'update_basket' %}');
                                }
                            };

                            config["renderingsettings"] = {
                                "label" : "Rendering Settings...",
                                "action" : false,
                                "submenu" : {
                                    "copy_rdef"  : {
                                        "label" : "Copy",
                                        "icon"  : '{% static "webclient/image/icon_basic_copy_16.png" %}',
                                        "action": function() {
                                            var inst = $.jstree.reference('#dataTree');
                                            copyRenderingSettings(inst.get_selected(true));
                                        }
                                    },
                                    "paste_rdef": {
                                        "label" : "Paste",
                                        "icon"  : '{% static "webclient/image/icon_basic_paste_16.png" %}',
                                        "action": function() {
                                            var inst = $.jstree.reference('#dataTree');
                                            pasteRenderingSettings(inst.get_selected(true));
                                        }
                                    },
                                    "reset_rdef": {
                                        "label" : "Set Imported and Save",
                                        "icon"  : '{% static "webclient/image/icon_basic_paste_16.png" %}',
                                        "action": function() {
                                            var inst = $.jstree.reference('#dataTree');
                                            resetRenderingSettings(inst.get_selected(true));
                                        }
                                    },
                                    "owner_rdef": {
                                        "label" : "Set Owner's and Save",
                                        "icon"  : '{% static "webclient/image/icon_basic_paste_16.png" %}',
                                        "action": function() {
                                            var inst = $.jstree.reference('#dataTree');
                                            applyOwnerRenderingSettings(inst.get_selected(true));
                                        }
                                    }
                                }
                            };

                            {% if myGroups|length < 2 %}
                                config["chgrp"]["_disabled"] = true;
                            {% endif %}

                            // List of permissions related disabling
                            // use canLink, canDelete etc classes on each node to enable/disable right-click menu

                            // TODO Potentially #8879 needs to be handled either by disabling all subnodes or by never
                            // creating them. As the menu is created anew each time there is no reason not to never create
                            // those nodes

                            // Disable delete if no canDelete permission
                            if (!OME.nodeHasPermission(node, 'canDelete', {{ active_group.id }})) {
                                config["delete"]["_disabled"] = true;
                            }

                            // Disable chGrp if no permission to change groups ('canChgrp')
                            if(!OME.nodeHasPermission(node, 'canChgrp', {{ active_group.id }})) {
                                config["chgrp"]["_disabled"] = true;
                            }

                            // For next section:
                            // locked is equivalent to saying that the item is not owned
                            // Basically, permission: canCreate = isOwned
                            // In my tree this can be checked by:
                            // node.data.obj.isOwned
                            // locked (isOwned) should perhaps jsut be another permission?

                            // Disable all the menus except createNew if an experimenter is the node
                            // Also disable createNew if that permission is not present
                            if (node.type === 'experimenter') {
                                // config['ccp']['_disabled'] = true;
                                config["ccp"]["submenu"]["copy"]["_disabled"] = true;
                                config["ccp"]["submenu"]["paste"]["_disabled"] = true;
                                config["ccp"]["submenu"]["cut"]["_disabled"] = true;
                                config['basket']['_disabled'] = true;

                                if (!OME.nodeHasPermission(node, 'isOwned', {{ active_group.id }})) {
                                    config["create"]["submenu"]["project"]["_disabled"] = true;
                                    config["create"]["submenu"]["dataset"]["_disabled"] = true;
                                    config["create"]["submenu"]["screen"]["_disabled"] = true;
                                }
                            } else if (node.type === 'orphaned') {

                            } else if (!OME.nodeHasPermission(node, 'canLink', {{ active_group.id }})) {
                                // Without 'canLink' disable create, basked and edit menus
                                // TODO Shouldn't Move To Group require canLink?
                                // see #8879 config["ccp"]["_disabled"] = true;
                                config["create"]["_disabled"] = true;
                                config["basket"]["_disabled"] = true;
                                config["create"]["submenu"]["project"]["_disabled"] = true;
                                config["create"]["submenu"]["dataset"]["_disabled"] = true;
                                config["create"]["submenu"]["screen"]["_disabled"] = true;
                                config["ccp"]["submenu"]["copy"]["_disabled"] = true;
                                config["ccp"]["submenu"]["paste"]["_disabled"] = true;
                                config["ccp"]["submenu"]["cut"]["_disabled"] = true;
                            } else {
                                // If there is a not a node to paste, disable paste
                                // Otherwise disable copy/cut.
                                // This is very bad behaviour, it should be possibly to copy/paste
                                // even if there is already something in the paste buffer. The
                                // originally cut item should just be restored to its previous position?

                                // If it's a dataset with no project parent, disable copy. WHY?

                                // If it's an orphaned image, disable copy. Ok, makes sense, but will also have
                                // to be done for d'n'd.

                                // If it's a screen disable copy/cut, create and basked
                                // Also, if there is something other than a plate to paste
                                // disable paste.

                                // If it's a plate
                                // Disable cut if the parent is experimenter, WHY?
                                // Disable Create
                                // Disable Paste
                                // Disable Basket

                                // If it's acquisition
                                // Disable ccp, create, basket, chgrp
                            }

                            // Disable setting of rendering settings if the node is not a dataset,
                            // plate, plate_acquisition or image
                            if (node.type !== 'dataset' &&
                                node.type !== 'plate' &&
                                node.type !== 'acquisition' &&
                                node.type !== 'image') {

                                config['renderingsettings']["submenu"]['paste_rdef']['_disabled'] = true;
                                config['renderingsettings']["submenu"]['reset_rdef']['_disabled'] = true;
                                config['renderingsettings']["submenu"]['owner_rdef']['_disabled'] = true;
                            }
                            // Only enable copying if an image is the node
                            if (node.type !== 'image') {
                                config['renderingsettings']["submenu"]['copy_rdef']['_disabled'] = true;
                            }

                            return config;
                        }

                    },
                    // TODO Performance of sort may not be realistic. The tree is mostly ordered correctly
                    // already, only insertions need to be corrected manually.
                    'sort': function(nodeId1, nodeId2) {
                        var inst = this;
                        var node1 = inst.get_node(nodeId1);
                        var node2 = inst.get_node(nodeId2);
                        // If the nodes are the same type then just compare lexicographically
                        if (node1.type === node2.type && node1.text != undefined && node2.text != undefined) {
                            // Unless they are experimenters and one of them is the current user.
                            if(node1.type === 'experimenter') {
                                if (node1.data.obj.id === {{ ome.user_id }}) {
                                    return -1;
                                } else if (node2.data.obj.id === {{ ome.user_id}}) {
                                    return 1;
                                }
                            }
                            return node1.text.toLowerCase() <= node2.text.toLowerCase() ? -1 : 1;
                        // Otherwise explicitly order the type that might be siblings
                        } else {

                            function getRanking(node) {
                                if (node.type === 'project') {
                                    return 1;
                                } else if (node.type === 'dataset') {
                                    return 2;
                                } else if (node.type === 'screen') {
                                    return 3;
                                } else if (node.type === 'plate') {
                                    return 4;
                                } else if (node.type === 'orphaned') {
                                    return 5;
                                } else {
                                    return 6;
                                }
                            }

                            var ranking1 = getRanking(node1);
                            var ranking2 = getRanking(node2);
                            return ranking1 <= ranking2 ? -1 : 1;
                        }
                    }
                });
        });
    </script>

    <!-- configure toolbar buttons -->
    <script type="text/javascript">

    $(function () {

        var inst = $.jstree.reference('#dataTree');

        // Attach click handlers to the individual buttons

        $('#addprojectButton').click(function() {
            OME.handleNewContainer("project");
        });

        $('#adddatasetButton').click(function() {
            OME.handleNewContainer("dataset");
        });

        $('#addscreenButton').click(function() {
            OME.handleNewContainer("screen");
        });

        $('#copyButton').click(function() {
            var objs = inst.get_selected(true)
            inst.copy(objs);
        });

        $('#cutButton').click(function() {
            var objs = inst.get_selected(true)
            inst.cut(objs);
        });

        $('#pasteButton').click(function() {
            var objs = inst.get_selected(true);
            if (objs.length == 1) {
                inst.paste(objs[0]);
                // Always disable paste button immediatly after using it
                enableToolbarButton('paste', false);
            }
        });

        $('#deleteButton').click(function() {
            // TODO Why does this not pass in selected!?!?!
            OME.handleDelete();
        });

        $('#basketButton').click(function() {
            var objs = inst.get_selected(true);
            OME.addToBasket(objs, '{% url 'update_basket' %}');
        });

        $('#refreshButton').click(function() {
            // Grab the paths to the items that are currently selected, for restoration later
            var selections = inst.get_selected();

            $.each(selections, function(index, selection) {
                 var path = inst.get_path(selection, false, true).reverse();
                 var refreshPathReverse = [];
                 $.each(path, function(index, pathComponent) {
                      var node = inst.get_node(pathComponent);
                      var tuple = [node.type, node.data.obj.id];
                      refreshPathReverse.push(tuple);
                 });
                 refreshPathsReverse.push(refreshPathReverse);

            });

            inst.deselect_all();
            inst.refresh();
        });

    });
    </script>

    <!-- set up the middle panel to only show the div chosen by <select> -->
    {% include "webclient/data/includes/center_plugin_init.js.html" %}

    <!-- include code to handle primary 'thumbs' middle plugin -->
    {% include "webclient/data/includes/center_plugin.thumbs.js.html" %}

    {% for cp in ome.center_plugins %}
        {% include cp.include %}
    {% endfor %}



{% endblock %}




{% block left %}

    <div id="left_panel_tabs" class="absolute_fill ui-tabs">
	
		
        <ul id="left_panel_tab_list" class="ui-tabs-nav">
			
			<!-- Remember to update this in public/public.html as well. We should change this, but for the meantime, you need to manually update the menu there too -->
			
	        <li id="explore_tab" class="ui-state-default ui-tabs-active"><a class="ui-tabs-anchor" title="Explore">{% trans "Explore" %}</a></li>
	        <li id="tags_tab" class="ui-state-default"><a href="{% url 'load_template' 'usertags' %}" class="ui-tabs-anchor">{% trans "Tags" %}</a></li>
	        <li id="public_tab" class="ui-state-default"><a href="{% url 'load_template' 'public' %}" class="ui-tabs-anchor">{% trans "Public" %}</a></li>
       
	    </ul>
		
		
		
		<!--
		<div id="navigator">
			<a href="#" id="back">Back</a>
			<a href="#" id="forward">Back</a>
			<dl>
				<dt>Groups</dt>
			</dl>
			<a href="#" id="settings">Settings</a>
		</div>
		-->
		
		
		


        <!-- toolbar above tree -->
        <div id="Projects">
            <ul class="toolbar">
					
			<li><input id="addprojectButton" class="button button-disabled" type="image" src="{% static "webclient/image/folder16.png" %}" alt="Create new project" title="Create new Project" /></li>
			<li><input id="adddatasetButton" class="button button-disabled" type="image" src="{% static "webclient/image/folder_image16.png" %}" alt="Create new dataset" title="Create new Dataset" /></li>
			<li><input id="addscreenButton" class="button button-disabled" type="image" src="{% static "webclient/image/folder_screen16.png" %}" alt="Create new screen" title="Create new Screen" /></li>
			
			<li class="seperator"></li>
			
			<li><input id="cutButton" class="button button-disabled" type="image" src="{% static "webclient/image/icon_toolbar_cut.png" %}" alt="Cut Link" title="Cut Link" /> </li>
            <li><input id="copyButton" class="button button-disabled" type="image" src="{% static "webclient/image/icon_toolbar_copy.png" %}" alt="Copy Link" title="Copy a link to the selected object" /> </li>
			<li><input id="pasteButton" class="button button-disabled" type="image" src="{% static "webclient/image/icon_toolbar_paste.png" %}" alt="Paste Link" title="Paste the copied link" /> </li>

			<li class="seperator">
			
			<li><input id="deleteButton" class="button button-disabled" type="image" src="{% static "webclient/image/icon_toolbar_delete.png" %}" alt="Delete" title="Delete" /> </li>
			<li><input id="basketButton" class="button button-disabled" type="image" src="{% static "webclient/image/icon_toolbar_basket.png" %}" alt="Add to basket" title="Add to basket"></li>
			
			<li class="seperator"></li>
			
			<li><input id="refreshButton" class="button" type="image" src="{% static "webclient/image/icon_toolbar_refresh.png" %}" alt="Refresh" title="Refresh"> </li>
					
            </ul>
            

            <div class="clear"></div>

            <div id="tree_details" class="left_panel_inner">
                <div class="dataTree" id="dataTree"></div>
            </div>
        </div>

        <!-- hidden form for delete dialogs -->
        <div id="delete-dialog-form" title="Delete" style="display:none">
            <p>Are you sure you want to delete the selected <span id="delete_type">Images</span>?</p>
            <p>If yes:</p>
            <form>
            <fieldset style="border: 0px solid white">
                <input type="checkbox" name="delete_anns" id="delete_anns" />
                Also delete any Annotations that become 'orphans'?<br/>
            </fieldset>
            </form>
        </div>

        <!-- hidden dialog for new Container -->
        <form id="new-container-form" title="New..." style="display:none">
            <p>Create a new <span id="new_container_type">Container</span>...</p>
            <p>
                <label for="id_name">Name:</label>
                {{ new_container_form.name }}
            </p>
            <p style="margin-bottom: 5px">
                <label for="id_description">Description:</label><br />
                {{ new_container_form.description }}
            </p>
        </form>

        <!-- hidden form for chgrp -->
        <form id="chgrp-form" title="Move to Group" action="{% url 'chgrp' %}" style="display:none" method="POST">
            <div id="move_group_tree" class="gray_border">
            </div>
        </form>

    </div>
{% endblock %}

{% block center %}

<div id="center_panel_header">
    <div id="center_panel_chooser">
        {% if ome.center_plugins|length > 0 %}
            <select id="source">
                <option value="#content_details">Thumbnails</option>
                {% for cp in ome.center_plugins %}
                    <option value="#{{ cp.plugin_id }}">{{ cp.label }}</option>
                {% endfor %}
            </select>
        {% endif %}
    </div>
</div>

<div id="content_details" class="center_panel_content"> </div>

{% for cp in ome.center_plugins %}
    <div id="{{ cp.plugin_id }}" class="center_panel_content"></div>
{% endfor %}

{% endblock %}



{% block right %}
<div>
    <div id="annotation_tabs" class="absolute_fill">
        <ul id="annotation_tabs_list">
            <li><a href="#metadata_general">{% trans "General" %}</a></li>
            <!-- include right tabs, as configured in settings.py under "omero.web.ui.right_tabs" -->
            {% for rt in ome.right_plugins %}
                <li><a href="#{{ rt.plugin_id }}">{{ rt.label }}</a></li>
            {% endfor %}
        </ul>
        <div id="metadata_general" class="right_tab_content" ></div>
        <!-- include right tab bodies, as configured in settings.py under "omero.web.ui.right_tabs" -->
        {% for rt in ome.right_plugins %}
        <div id="{{ rt.plugin_id }}" class="right_tab_content" ></div>
        {% endfor %}
    </div>
</div>
{% endblock %}


