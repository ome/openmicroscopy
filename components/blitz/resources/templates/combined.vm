#*
 *   $Id$
 *
 *   Copyright 2007-2014 Glencoe Software, Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 *
 *#

Note: lines not prefixed with [...] will be omitted in the final product.
The other prefixes are used by blitz/build.xml to determine how this file
wil be split. This is done because the individual velocity if/elseif's
and sets are nearly identical.

Here we turn off all prefixes except for ice.  Since <>I files are
concrete implementations, they should only be generated for concrete
classes. Capitalized versions will be turned on even for abstract classes.

#set( $ALL = "all" )
#set( $JAV = "jav" )
#set( $CPP = "cpp" )
#set( $HDR = "hdr" )
#set( $PYC = "pyc" )
#set( $ice = "ice" )
#set( $all = "all" )
#set( $jav = "jav" )
#set( $cpp = "cpp" )
#set( $hdr = "hdr" )
#set( $pyc = "pyc" )
#if($type.abstract)
#set( $all = "abs" )
#set( $jav = "abs" )
#set( $cpp = "abs" )
#set( $hdr = "abs" )
#set( $pyc = "abs" )
#end

Copyright notice added to all files:
[$PYC] """
[$ALL]    /*
[$ALL]    **   Generated by blitz/templates/resouces/combined.vm
[$hdr]    **   See ../../README.h for information on these types.
[$ice]    **   See ../../README.ice for information on these types.
[$ALL]    **
[$ALL]    **   Copyright 2007, 2008 Glencoe Software, Inc. All rights reserved.
[$ALL]    **   Use is subject to license terms supplied in LICENSE.txt
[$ALL]    **
[$ALL]    */
[$PYC] """

#if($type.abstract)
[$HDR]
[$CPP]
[$PYC]
[$HDR] // File may be empty since type is abstract
[$CPP] // File may be empty since type is abstract
[$PYC] ## File may be empty since type is abstract
[$HDR]
[$CPP]
[$PYC]
#end

CONSTANTS -- Don't change for whole file
#set($Pojo  = "${type.shortname}")
#set($PojoI = "${Pojo}I")
#set($POJO  = "${Pojo.toUpperCase()}")
#set($POJOI = "${PojoI.toUpperCase()}")
#set($JAV_CURRENT = "Ice.Current current" )
#set($PYC_CURRENT = "current = None" )
#set($CPP_CURRENT = "const Ice::Current& current" )
#set($CPP_CURRENT_UNUSED = "const Ice::Current& /* current */" )
#set($HDR_CURRENT = "${CPP_CURRENT} = Ice::Current()")


DECLARATION BLOCK:
=====================================================================================================

[$ice] #ifndef ${POJO}_ICE
[$ice] #define ${POJO}_ICE
[$hdr] #ifndef ${POJOI}_H
[$hdr] #define ${POJOI}_H

[$ice] \#include <omero/model/IObject.ice>
[$ice] \#include <omero/RTypes.ice>
[$ice] \#include <omero/model/RTypes.ice>
[$ice] \#include <omero/System.ice>
[$ice] \#include <omero/Collections.ice>
#if( $type.superclass )
#set( $parent = $type.superclass.replaceFirst(".*ome.model..+?[.]","") )
[$ice] \#include <omero/model/${parent}.ice>
#end
[$hdr] \#include <omero/IceNoWarnPush.h>
[$hdr] \#include <omero/RTypes.h>
[$hdr] \#include <omero/model/RTypes.h>
[$hdr] \#include <omero/model/IObject.h>
[$hdr] \#include <omero/model/${Pojo}.h>
[$hdr] \#include <omero/IceNoWarnPop.h>
[$hdr] \#include <omero/ClientErrors.h>
[$hdr] \#include <omero/model/DetailsI.h>
[$hdr] \#include <omero/model/NamedValue.h>
[$hdr] \#include <omero/templates.h>
[$hdr] \#include <IceUtil/Config.h>
[$hdr] \#include <Ice/Handle.h>

[$hdr] #ifndef OMERO_CLIENT
[$hdr] #   ifdef OMERO_CLIENT_EXPORTS
[$hdr] #       define OMERO_CLIENT ICE_DECLSPEC_EXPORT
[$hdr] #   else
[$hdr] #       define OMERO_CLIENT ICE_DECLSPEC_IMPORT
[$hdr] #   endif
[$hdr] #endif
[$cpp] #ifndef OMERO_CLIENT_EXPORTS
[$cpp] #   define OMERO_CLIENT_EXPORTS
[$cpp] #endif

[$ice] module omero {
[$ice]   module model {

## CONSTANTS
#if($type.class.name == "ome.dsl.EnumType")
[$ice]
[$ice]     module enums {
#foreach($prop in $type.properties)
#if($prop.class.name == "ome.dsl.EntryField")
### HACK: the enum
### bf/components/xsd-fu/xsd-fu: def enum_value_name()
#set($enumSymbol = ${prop.name.replaceAll("[^a-zA-Z0-9]","")})
#if($Pojo.startsWith("Units"))
#set($enumSymbol1 = ${enumSymbol.substring(1)})
#if($prop.name.startsWith("M"))
#set($enumSymbol = "mega${enumSymbol1}")
#elseif($prop.name.startsWith("G"))
#set($enumSymbol = "giga${enumSymbol1}")
#elseif($prop.name.startsWith("P"))
#set($enumSymbol = "peta${enumSymbol1}")
#elseif($prop.name.startsWith("E"))
#set($enumSymbol = "exa${enumSymbol1}")
#elseif($prop.name.startsWith("Z"))
#set($enumSymbol = "zetta${enumSymbol1}")
#elseif($prop.name.startsWith("Y"))
#set($enumSymbol = "yotta${enumSymbol1}")
#elseif($prop.name.startsWith("T") && !$prop.name.startsWith("o"))
#set($enumSymbol = "tera${enumSymbol1}")
#elseif($prop.name.codePointAt(0) > 128) ## Workaround: startsWith("Âµ") fails on non-UTF-8 locales
#set($enumSymbol = "micro${enumSymbol1}")
#end
#end
#set($enumName = "${Pojo}${enumSymbol}")
[$ice]         const string ${enumName} = "${prop.name}";
#end
#end
[$ice]     };
[$ice]
#end

#foreach( $property in $type.propertyClosure )
#if($property.type.startsWith("ome"))
#if($property.isLink)
[$ice]     class ${property.shortType};
[$cpp] \#include <omero/model/${property.shortType}I.h> // Impl. since instantiated
#if($property.shortTarget)
[$ice]     class ${property.shortTarget};
[$cpp] \#include <omero/IceNoWarnPush.h>
[$cpp] \#include <omero/model/${property.shortTarget}.h>
[$cpp] \#include <omero/IceNoWarnPop.h>
#end
#else
[$ice]     class ${property.shortType};
[$cpp] \#include <omero/IceNoWarnPush.h>
[$cpp] \#include <omero/model/${property.shortType}.h>
[$cpp] \#include <omero/IceNoWarnPop.h>
#end##link
#end##ome
#end##foreach

[$jav] package omero.model;
[$jav] import java.util.*;
[$jav] import static omero.rtypes.*;
[$jav] import ome.conditions.*;
[$jav] public class ${PojoI} extends ${Pojo}
[$jav]    implements ome.model.ModelBased {

Note how the whitespace for the python definitions is important.
[$pyc] import Ice
[$pyc] import IceImport
[$pyc] import omero
[$pyc] IceImport.load("omero_model_DetailsI")
[$pyc] IceImport.load("omero_model_${Pojo}_ice")
[$pyc] from omero.rtypes import rlong
[$pyc] from collections import namedtuple
[$pyc] _omero = Ice.openModule("omero")
[$pyc] _omero_model = Ice.openModule("omero.model")
[$pyc] __name__ = "omero.model"

[$pyc] class ${PojoI}(_omero_model.$Pojo):
[$pyc]
[$pyc]       # Property Metadata
[$pyc]       _field_info_data = namedtuple("FieldData", ["wrapper", "nullable"])
[$pyc]       _field_info_type = namedtuple("FieldInfo", [
#foreach($property in $type.propertyClosure)#############
[$pyc]           "${property.name}",
#end
[$pyc]       ])
[$pyc]       _field_info = _field_info_type(
#foreach($property in $type.propertyClosure)#############
#set( $javaType = $property.type )
#if($property.nullable)
#set( $metanullable = "True")
#else
#set( $metanullable = "False")
#end
#set( $shortType = $type.unqualify($javaType) )
#if( $javaType.startsWith("ome"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.proxy_to_instance, nullable=$metanullable),
#elseif( $javaType.startsWith("java.lang.Boolean"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.rtypes.rbool, nullable=$metanullable),
#elseif( $javaType.startsWith("java.lang.Integer"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.rtypes.rint, nullable=$metanullable),
#elseif( $javaType.startsWith("java.lang.Long"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.rtypes.rlong, nullable=$metanullable),
#elseif( $javaType.startsWith("java.lang.Double"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.rtypes.rdouble, nullable=$metanullable),
#elseif( $javaType.startsWith("java.lang.Float"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.rtypes.rfloat, nullable=$metanullable),
#elseif( $javaType.startsWith("long")) ## for Permissions
[$pyc]           ${property.name}=_field_info_data(wrapper=long, nullable=$metanullable),
#elseif( $javaType.startsWith("java.sql.Timestamp"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.rtypes.rtime, nullable=$metanullable),
#elseif( $javaType.startsWith("java.lang.String"))
[$pyc]           ${property.name}=_field_info_data(wrapper=omero.rtypes.rstring, nullable=$metanullable),
#else
[$pyc]           ${property.name}=_field_info_data(wrapper=None, nullable=$metanullable),
[$pyc]
#end
#end
[$pyc]       )  # end _field_info
[$hdr] namespace omero {
[$hdr]   namespace model {
[$hdr]     class OMERO_CLIENT ${PojoI};
[$hdr]   }
[$hdr] }
[$hdr] namespace IceInternal {
[$hdr]   OMERO_CLIENT ::Ice::Object* upCast(::omero::model::${PojoI}*);
[$hdr] }
[$hdr] namespace omero {
[$hdr]   namespace model {
[$hdr]   typedef IceInternal::Handle<${PojoI}> ${PojoI}Ptr;
[$hdr]     class OMERO_CLIENT ${PojoI} : virtual public ${Pojo} {

[$cpp] \#include <omero/model/${Pojo}I.h>
[$cpp] \#include <omero/RTypesI.h>
[$cpp] ::Ice::Object* IceInternal::upCast(::omero::model::${PojoI}* p) { return p; }
[$cpp] using omero::rtypes::rlong;
[$cpp] namespace omero {
[$cpp]   namespace model {

STATIC FIELDS:

[$hdr]    public:
#foreach( $property in $type.propertyClosure )
[$jav]       public final static String ${property.nameUpper} = "${type.id}_${property.name}";
[$pyc]       ${property.nameUpper} =  "${type.id}_${property.name}"
[$hdr]       static const std::string ${property.nameUpper};
[$cpp]       const std::string ${PojoI}::${property.nameUpper} =  "${type.id}_${property.name}";
#end

[$hdr]     protected:

INTERNAL METHODS:

[$hdr]       void errorIfUnloaded();
[$cpp]       void ${PojoI}::errorIfUnloaded()
[$cpp]       {
[$cpp]         if (! loaded ) throw omero::UnloadedEntityException(__FILE__,__LINE__,"Object unloaded");
[$cpp]       }
[$jav]       protected void errorIfUnloaded() throws omero.UnloadedEntityException
[$jav]       {
[$jav]         if ( ! loaded ) throw new omero.UnloadedEntityException("Object unloaded:"+this);
[$jav]       }
[$pyc]       def errorIfUnloaded(self):
[$pyc]           if not self._loaded:
[$pyc]               raise _omero.UnloadedEntityException("Object unloaded:"+str(self))
[$pyc]
[$hdr]       void throwNullCollectionException(std::string propertyName);
[$cpp]       void ${PojoI}::throwNullCollectionException(std::string propertyName)
[$cpp]       {
[$cpp]         std::string s = "Error updating collection:" + propertyName +"\n"+
[$cpp]         "Collection is currently null. This can be seen\n"+
[$cpp]         "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$cpp]         "that this collection was unloaded. Please refresh this object\n"+
[$cpp]         "in order to update this collection.\n";
[$cpp]         throw omero::UnloadedCollectionException(
[$cpp]            __FILE__,__LINE__,s.c_str());
[$cpp]       }
[$jav]       protected void throwNullCollectionException(String propertyName) throws omero.UnloadedCollectionException
[$jav]       {
[$jav]          throw new omero.UnloadedCollectionException(
[$jav]            "Error updating collection:" + propertyName +"\n"+
[$jav]            "Collection is currently null. This can be seen\n"+
[$jav]            "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$jav]            "that this collection was unloaded. Please refresh this object\n"+
[$jav]            "in order to update this collection.\n"
[$jav]            );
[$jav]       }
[$pyc]       def throwNullCollectionException(self,propertyName):
[$pyc]           raise _omero.UnloadedEntityException(""+
[$pyc]           "Error updating collection:" + propertyName +"\n"+
[$pyc]           "Collection is currently null. This can be seen\n" +
[$pyc]           "by testing \""+ propertyName +"Loaded\". This implies\n"+
[$pyc]           "that this collection was unloaded. Please refresh this object\n"+
[$pyc]           "in order to update this collection.\n")
[$pyc]


TOGGLE AND CREATE COLLECTIONS:
=====================================================================================================

[$jav]       protected void toggleCollectionsLoaded(boolean load) {
#set($propertyClosureVar = "/*unused*/")
#foreach( $property in $type.propertyClosure )
#if(  $property.one2Many )
#set($propertyClosureVar = "load")
#end
#end
[$hdr]       virtual void toggleCollectionsLoaded(bool ${propertyClosureVar});
[$cpp]    void ${PojoI}::toggleCollectionsLoaded(bool ${propertyClosureVar}) {
[$pyc]       def _toggleCollectionsLoaded(self, load):
#foreach( $property in $type.propertyClosure )
#set(     $PropertyName = $property.nameCapped )
#set(     $javaType = $property.type)
#set(     $ActualPojo = $property.actualType.shortname)
#set(     $seqName = "${ActualPojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set($genericType = $property.type)
#set($genericType = $genericType.replaceFirst("ome.model..+?[.]","omero::model::"))
#set($genericTypeC = "${genericType.replaceAll('[.]','::')}")

Here we don't have to keep up with the type (set/list)
since all collections are lists in ice.

##
## Some lines should only be present in superclasses.
## Those are marked with an uppercased version.
##
#if( $type.id.equals($property.actualType.id) )
#set($Ice = "ice" )
#else
#set($Ice = "NOT" )
#end

#if(  $property.one2Many )
[$Ice]     ["java:type:java.util.ArrayList"] sequence<$genericTypeC> ${seqName};
#if( $property.isLink )
## TODO: this could be defined just once if done carefully.
[$Ice]     ["java:type:java.util.ArrayList"] sequence<omero::model::${property.shortTarget}> ${Pojo}Linked${property.targetName}Seq;
#end

[$jav]           if (load) {
[$jav]               ${property.name}Seq = new ArrayList();
[$jav]               ${property.name}Loaded = true;
[$jav]           } else {
[$jav]               ${property.name}Seq = null;
[$jav]               ${property.name}Loaded = false;
[$jav]           }
[$cpp]           if (load) {
[$cpp]               ${property.name}Seq = ${seqName}();
[$cpp]               ${property.name}Loaded = true;
[$cpp]           } else {
[$cpp]               ${property.name}Seq.clear();
[$cpp]               ${property.name}Loaded = false;
[$cpp]           }
[$pyc]           if load:
[$pyc]               self._${property.name}Seq = []
[$pyc]               self._${property.name}Loaded = True;
[$pyc]           else:
[$pyc]               self._${property.name}Seq = []
[$pyc]               self._${property.name}Loaded = False;
[$pyc]
#end##
#end##FOREACH
[$jav]      }
[$cpp]      }
##               In case there are no collections
[$pyc]           pass
[$pyc]


DESTRUCTOR BLOCK:
=====================================================================================================

[$hdr]       virtual ~${PojoI}();
[$cpp]     ${PojoI}::~${PojoI}() {}

[$hdr]     public:


DEFAULT CONSTRUCTOR BLOCK:
=====================================================================================================


[$hdr]       ${PojoI}();
[$jav]       public ${PojoI}() {
[$cpp]       ${PojoI}::${PojoI}() : ${Pojo}() {
[$cpp]           loaded = true;
[$cpp]           toggleCollectionsLoaded(true);
[$cpp]           details = new omero::model::DetailsI();
[$jav]           loaded = true;
[$jav]           toggleCollectionsLoaded(true);
[$jav]           details = new omero.model.DetailsI();
[$jav]       }
[$cpp]       }

Python combines the two constructors. See below for a comparison.
[$pyc]       def __init__(self, id=None, loaded=None):
[$pyc]           super(${Pojo}I, self).__init__()
[$pyc]           if id is not None and isinstance(id, (str, unicode)) and ":" in id:
[$pyc]               parts = id.split(":")
[$pyc]               if len(parts) != 2:
[$pyc]                   raise Exception("Invalid proxy string: %s", id)
[$pyc]               if parts[0] != self.__class__.__name__ and \
[$pyc]                  parts[0]+"I" != self.__class__.__name__:
[$pyc]                   raise Exception("Proxy class mismatch: %s<>%s" %
[$pyc]                   (self.__class__.__name__, parts[0]))
[$pyc]               self._id = rlong(parts[1])
[$pyc]               if loaded is None:
[$pyc]                   # If no loadedness was requested with
[$pyc]                   # a proxy string, then assume False.
[$pyc]                   loaded = False
[$pyc]           else:
[$pyc]               # Relying on omero.rtypes.rlong's error-handling
[$pyc]               self._id = rlong(id)
[$pyc]               if loaded is None:
[$pyc]                   loaded = True  # Assume true as previously
[$pyc]           self._loaded = loaded
[$pyc]           if self._loaded:
[$pyc]              self._details = _omero_model.DetailsI()
[$pyc]              self._toggleCollectionsLoaded(True)
[$pyc]

ICE CLASS BLOCK:
=====================================================================================================

Calculate inheritance. This is done here because sequences must first be defined.

#set( $base = "omero::model::IObject" )
#set( $extendsDeclaration = $base )
#if(  $type.superclass )
#set( $extendsDeclaration = $type.superclass.replaceFirst("ome.model..+?[.]","omero::model::" ) )
#end

[$ice]     ["protected"] class ${type.shortname}
[$ice]     extends $extendsDeclaration
[$ice]     {

UNLOADED CONSTRUCTOR BLOCK:
=====================================================================================================

[$hdr]       ${PojoI}(omero::RLongPtr idPtr, bool isLoaded = false);
[$cpp]    ${PojoI}::${PojoI}(omero::RLongPtr idPtr, bool isLoaded) : ${Pojo}() {
[$cpp]        id = idPtr;
[$cpp]        loaded = isLoaded;
[$cpp]        if (loaded) details = new omero::model::DetailsI();
[$cpp]        toggleCollectionsLoaded(isLoaded);
[$cpp]    }

[$hdr]       ${PojoI}(Ice::Long id, bool isLoaded = false);
[$cpp]    ${PojoI}::${PojoI}(Ice::Long _id, bool isLoaded) : ${Pojo}() {
[$cpp]        id = rlong(_id);
[$cpp]        loaded = isLoaded;
[$cpp]        if (loaded) details = new omero::model::DetailsI();
[$cpp]        toggleCollectionsLoaded(isLoaded);
[$cpp]    }


[$jav]    public ${PojoI}(long id, boolean loaded) {
[$jav]        this( rlong(id), loaded );
[$jav]    }

[$jav]    public ${PojoI}(omero.RLong id, boolean loaded) {
[$jav]        this.id = id;
[$jav]        this.loaded = loaded;
[$jav]        if (loaded) details = new omero.model.DetailsI();
[$jav]        toggleCollectionsLoaded(loaded);
[$jav]    }

See single Python constructor above.

LOADNESS BLOCK:
=====================================================================================================

[$jav]       public void unload($JAV_CURRENT) {
[$hdr]       virtual void unload($HDR_CURRENT);
[$cpp]       void ${PojoI}::unload($CPP_CURRENT_UNUSED) {
[$pyc]       def unload(self, $PYC_CURRENT):
[$pyc]           self._loaded = False
[$jav]           loaded = false;
[$cpp]           loaded = false;
#foreach($property in $type.propertyClosure)
#if(!$clazz.identifierProperty.equals($property))
#set( $PropertyName = $property.nameCapped )
[$jav]           unload${PropertyName}( );
[$cpp]           unload${PropertyName}( );
[$pyc]           self.unload${PropertyName}( )
#end
#end##FOREACH
[$pyc]
[$jav]    }
[$cpp]    }

[$jav]       public boolean isLoaded($JAV_CURRENT) {
[$hdr]       virtual bool isLoaded($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isLoaded($CPP_CURRENT_UNUSED) {
[$pyc]       def isLoaded(self, $PYC_CURRENT):
[$pyc]           return self._loaded
[$jav]           return loaded;
[$cpp]           return loaded;
[$jav]    }
[$cpp]    }

[$jav]       public void unloadCollections($JAV_CURRENT) {
[$jav]           toggleCollectionsLoaded(false);
[$jav]       }

[$hdr]       virtual void unloadCollections($HDR_CURRENT);
[$cpp]       void ${PojoI}::unloadCollections($CPP_CURRENT_UNUSED) {
[$cpp]           toggleCollectionsLoaded(false);
[$cpp]       }
[$pyc]       def unloadCollections(self, $PYC_CURRENT):
[$pyc]           self._toggleCollectionsLoaded( False )

INTERFACE METHODS:
=====================================================================================================
Since all the language bindings don't support the concept of interfaces,
the IObject abstract base class declares several methods that all concrete
implementations must define.

[$jav]       public boolean isGlobal($JAV_CURRENT) {
[$jav]           return #if($type.global) true #else false #end;
[$jav]       }
[$hdr]       virtual bool isGlobal($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isGlobal($CPP_CURRENT_UNUSED) {
[$cpp]           return #if($type.global) true #else false #end;
[$cpp]       }
[$pyc]       def isGlobal(self, $PYC_CURRENT):
[$pyc]           return #if($type.global) True #else False #end;

[$jav]       public boolean isMutable($JAV_CURRENT) {
[$jav]           return #if($type.immutable) false #else true #end;
[$jav]       }
[$hdr]       virtual bool isMutable($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isMutable($CPP_CURRENT_UNUSED) {
[$cpp]           return #if($type.immutable) false #else true #end;
[$cpp]       }
[$pyc]       def isMutable(self, $PYC_CURRENT):
[$pyc]           return #if($type.immutable) False #else True #end;

[$jav]       public boolean isAnnotated($JAV_CURRENT) {
[$jav]           return #if($type.annotated) true #else false #end;
[$jav]       }
[$hdr]       virtual bool isAnnotated($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isAnnotated($CPP_CURRENT_UNUSED) {
[$cpp]           return #if($type.annotated) true #else false #end;
[$cpp]       }
[$pyc]       def isAnnotated(self, $PYC_CURRENT):
[$pyc]           return #if($type.annotated) True #else False #end;

[$jav]       public boolean isLink($JAV_CURRENT) {
[$jav]           return #if($type.isLink) true #else false #end;
[$jav]       }
[$hdr]       virtual bool isLink($HDR_CURRENT);
[$cpp]       bool ${PojoI}::isLink($CPP_CURRENT_UNUSED) {
[$cpp]           return #if($type.isLink) true #else false #end;
[$cpp]       }
[$pyc]       def isLink(self, $PYC_CURRENT):
[$pyc]           return #if($type.isLink) True #else False #end;


SPECIAL METHODS:
=====================================================================================================
Id and Details acccesors defined like accessors below. This is necessary here
since id and details (like the loadedness methods above) are defined in IObject.ice
and cannot appear in every concrete <>I class. Therefore, we define them here
and protect later FOREACH blocks with "if (name == 'id' || name == 'details') skip;"

[$jav]       public omero.model.IObject shallowCopy($JAV_CURRENT) {
[$hdr]       virtual omero::model::IObjectPtr shallowCopy($HDR_CURRENT);
[$cpp]       omero::model::IObjectPtr ${PojoI}::shallowCopy($CPP_CURRENT_UNUSED) {
[$pyc]       def shallowCopy(self, $PYC_CURRENT):

[$jav]             if ( ! loaded ) return proxy();
[$cpp]             if ( ! loaded ) return proxy();
[$pyc]             if not self._loaded: return self.proxy()

[$jav]             ${Pojo} copy = new ${PojoI}();
[$cpp]             ${Pojo}Ptr copy = new ${PojoI}();
[$pyc]             copy = ${PojoI}()

[$jav]             copy.id = id;
[$cpp]             copy->setId( id );
[$pyc]             copy._id = self._id;

#if( ! $type.immutable )

[$jav]             copy.version = version;
[$cpp]             copy->setVersion( version );
[$pyc]             copy._version = self._version;

#end## ! immutable
#foreach($property in $type.propertyClosure)
#if($property.name  == "details")

[$jav]             copy.details = null; // Unloading for the moment.
[$cpp]             // FIXME copy->details = omero::model::DetailsPtr(); // Unloading for the moment.
[$pyc]             copy._details = None  # Unloading for the moment.

[$cpp]             throw omero::ClientError(__FILE__, __LINE__, "NYI");
[$cpp]         }
[$pyc]             raise omero.ClientError("NYI")

#elseif($property.one2Many)
[$jav]             if (${property.name}Loaded == false) {
[$jav]                 copy.${property.name}Loaded = false;
[$jav]                 copy.${property.name}Seq = null;
[$jav]             } else {
[$jav]                 copy.${property.name}Loaded = true;
[$jav]                 copy.${property.name}Seq = new ArrayList();
[$jav]                 for (${property.shortType} item : ${property.name}Seq) {
[$jav]     		       copy.${property.name}Seq.add( item == null ? null : (${property.shortType}) item.proxy() );
[$jav]                 }
[$jav]             }
#elseif($property.type.startsWith("ome.model.units"))
[$jav]             copy.${property.name} = ${property.name} == null ? null : (${property.shortType}) ${property.name}.copy();
#elseif($property.type.startsWith("ome") || $property.type.startsWith("IObject"))
[$jav]             copy.${property.name} = ${property.name} == null ? null : (${property.shortType}) ${property.name}.proxy();
#else
[$jav]             copy.${property.name} = ${property.name}; // Assumes immutable
#end
#end##FOREACH
[$jav]             return copy;
[$jav]       }


[$jav]       public IObject proxy($JAV_CURRENT) {
[$jav]           if (this.id == null) throw new omero.ClientError("Proxies require an id");
[$jav]           return new $PojoI( this.id.getValue(), false );
[$jav]       }
[$jav]
[$jav]
[$jav]       public omero.RLong getId($JAV_CURRENT) {
[$jav]           return id;
[$jav]       }
[$jav]
[$jav]       public void setId( omero.RLong id, $JAV_CURRENT ) {
[$jav]           this.id = id;
[$jav]       }
[$jav]
[$jav]       public omero.model.Details getDetails($JAV_CURRENT) {
[$jav]           errorIfUnloaded();
[$jav]           return this.details;
[$jav]       }
[$jav]
[$jav]       public void unloadDetails($JAV_CURRENT) {
[$jav]           this.details = null;
[$jav]       }
[$jav]
[$jav]       /**
[$jav]        * Method used by copyObject below to take an ome.model instance and
[$jav]        * set the values on this instance.
[$jav]        */
[$jav]       private void copyDetails(ome.model.IObject source, omero.util.IceMapper mapper) {
[$jav]           this.details = (omero.model.Details) mapper.findTarget( source.getDetails() );
[$jav]       }
[$jav]
[$jav]       /**
[$jav]        * Method used by fillObject below to take this instance and
[$jav]        * set the values on the target ome.model. instance.
[$jav]        */
[$jav]       private void fillDetails(ome.model.IObject target, omero.util.IceMapper mapper) {
[$jav]           ome.model.internal.Details details = (ome.model.internal.Details) mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() );
[$jav]           if (details != null) {
[$jav]               target.getDetails().copy( details );
[$jav]           }
[$jav]       }
[$jav]

[$hdr]       virtual omero::model::IObjectPtr proxy($HDR_CURRENT);
[$hdr]       virtual omero::model::DetailsPtr getDetails($HDR_CURRENT);
[$hdr]       virtual void unloadDetails($HDR_CURRENT);
[$hdr]       virtual omero::RLongPtr getId($HDR_CURRENT);
[$hdr]       virtual void setId( const omero::RLongPtr& id, $HDR_CURRENT );

[$cpp]       omero::model::IObjectPtr ${PojoI}::proxy($CPP_CURRENT_UNUSED) {
[$cpp]           if ( ! id )  throw new omero::ClientError(__FILE__, __LINE__, "Proxies require an id");
[$cpp]           return new ${PojoI}( id->getValue(), false );
[$cpp]       }
[$cpp]
[$cpp]       omero::model::DetailsPtr ${PojoI}::getDetails($CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           return details;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::unloadDetails($CPP_CURRENT_UNUSED) {
[$cpp]           details = omero::model::DetailsPtr();
[$cpp]       }
[$cpp]
[$cpp]       omero::RLongPtr ${PojoI}::getId($CPP_CURRENT_UNUSED) {
[$cpp]           return id;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::setId(const omero::RLongPtr& _id, $CPP_CURRENT_UNUSED) {
[$cpp]           id = _id;
[$cpp]       }

[$pyc]       def proxy(self, $PYC_CURRENT):
[$pyc]           if self._id is None: raise omero.ClientError("Proxies require an id")
[$pyc]           return ${PojoI}( self._id.getValue(), False )
[$pyc]
[$pyc]       def getDetails(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self._details
[$pyc]
[$pyc]       def unloadDetails(self, $PYC_CURRENT):
[$pyc]           self._details = None
[$pyc]
[$pyc]       def getId(self, $PYC_CURRENT):
[$pyc]           return self._id
[$pyc]
[$pyc]       def setId(self, _id, $PYC_CURRENT):
[$pyc]           self._id = _id
[$pyc]
Doing unloadedPython as a method because of the multi-line restriction. See below.
[$pyc]       def checkUnloadedProperty(self, value, loadedField):
[$pyc]           if value == None:
[$pyc]               self.__dict__[loadedField] = False
[$pyc]           else:
[$pyc]               self.__dict__[loadedField] = True
[$pyc]


MUTABLE
=====================================================================================================
The "version" property is not a part of the model but is calculated from mutability.

#if( ! $type.immutable )
#if( ! $type.superclass )
[$ice]       omero::RInt version;
[$ice]       omero::RInt getVersion();
[$ice]       void setVersion(omero::RInt theVersion);
#end ! superclass

[$jav]       public omero.RInt getVersion($JAV_CURRENT) {
[$jav]           errorIfUnloaded();
[$jav]           return this.version;
[$jav]       }
[$jav]
[$jav]       public void setVersion( omero.RInt version, $JAV_CURRENT ) {
[$jav]           this.version = version;
[$jav]       }
[$jav]

[$hdr]       virtual omero::RIntPtr getVersion($HDR_CURRENT);
[$hdr]       virtual void setVersion( const omero::RIntPtr& version, $HDR_CURRENT );

[$cpp]       omero::RIntPtr ${PojoI}::getVersion($CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           return version;
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::setVersion(const omero::RIntPtr& _version, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           version = _version;
[$cpp]       }

[$pyc]       def getVersion(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self._version
[$pyc]
[$pyc]       def setVersion(self, version, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self._version = version
[$pyc]
#end### ! immutable


###########################################################################
#foreach($property in $type.propertyClosure)#############
###########################################################################

This is the main loop through all of the properties. Where possible, methods
should be created here which simplify the other sections of code generation.

FIELD & ACCESSORS BLOCK:
=====================================================================================================

These mappings are from HibernateTypes-->IceTypes

Ice properties should only be defined once (not in every subclass, obviously).
However, because of Ice's inheritance structure, we are here using
propertyClosure which gives us superclass fields. These must be filtered
in the [Ice] sections below, but not for all others.

#if( $property.name.equals("id") || $property.name.equals("details"))## SPECIAL EXCEPTIONS

Skip. These are defined in omero.IObject.ice

#else## All other properties are treated normally

[$hdr]
[$hdr]       //
[$hdr]       //  ${Pojo}.${property.name}
[$hdr]       //

#set( $ActualPojo = $property.actualType.shortname )
#set($Ice = "NOT" ) ## Ice only activated when property defined here
#if( $type.id.equals($property.actualType.id) )
#set($Ice = "ice" )
#end

Properties used throughout the accessor generation

## TODO: UNIFY THESE
#set( $PropertyName = $property.nameCapped)
#set( $STATICFIELDNAME = "${type.id}.${PropertyName.toUpperCase()}" )
#set( $javaType = $property.type )
#set( $shortType = $type.unqualify($javaType) )
#set( $iceType = "ERROR" )## Must be reset on each iteration
#set( $cppType = "ERROR" )##  ditto
#set( $open = " " )
#set( $close= " " )
#set( $prefix=" " )
#set( $suffix=" " )
#set( $unloadedJava=" " )
#set( $unloadedCpp=" " )
#set( $unloadedPython="pass" )
#set( $copyMethod = "ERROR" )
#set( $fieldName = "${property.name}") ## Changed for sequences to nameSeq
#set( $getter = "this.${fieldName}" )
#set( $setter = "${fieldName}" )

 TODO: Currently the findTarget methods have separate names.
 Instead there should be a cast to guarantee that the right
 method is invoked.

## Here we are taking the pojo name from the ST of the property, rather than the
## current ST in order to handle subclasses wrt. links. This may need to be done for
## every property right after the foreach.
#set( $truePojo = "${property.st.shortname}" )
#set( $seqName = "${truePojo}${PropertyName.substring(0,1).toUpperCase()}${PropertyName.substring(1,$PropertyName.length())}Seq" )## seqName copied from ice_defs.vm
#set( $propLoaded = "${property.Name}Loaded" )

## TODO use empty List or null?

#if( $property.one2Many )##JAVA_TYPE ----------------------------------------------
## #684 Mapping all sets to lists.
#set( $javaType = "java.util.List" )
#set( $getter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( this.$property.name ) " )
#set( $setter = "${property.name} == null ? new java.util.ArrayList() : new java.util.ArrayList( $property.name )" )
#set( $unloadedJava = "if (${property.name} == null) { this.${propLoaded} = false; } else { this.${propLoaded} = true; }" )
#set( $cppType = "$seqName" )
#set( $iceType = "$seqName" )
#set( $unloadedCpp = "if (_${property.name} != static_cast<$cppType>(0)) { ${propLoaded} = true; } else { ${propLoaded} = false; }" )
#set( $unloadedPython = "self.checkUnloadedProperty(_${property.name},'${propLoaded}')" )
#set( $fieldName = "${property.name}Seq")
#set( $getter = "this.${fieldName}" )
## See ticket:684
## If this is the case, we can't use the accessor and have to use a generated method
#set( $copyMethod = "this.set${PropertyName}( ($javaType) mapper.findCollection( (Collection) source.retrieve(${type.id}.${PropertyName.toUpperCase()})), null /* FIXME - argument unneeded */);" )

[$Ice]       $seqName ${fieldName};
[$Ice]       bool ${property.name}Loaded;
#if( $property.isLink && !$property.actualTarget.global)
[$Ice]       omero::sys::CountMap ${property.name}CountPerOwner;
#end

#elseif( $javaType.startsWith("ome"))## Had to be moved before "*Map" rule ---------
#set( $javaType = "omero.model.${shortType}" )
#set( $getter = "(omero.model.${shortType}) this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::model::${shortType}" )
#set( $cppType = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = ($javaType) mapper.findTarget(source.get${PropertyName}());" );
[$Ice]       omero::model::${shortType} ${property.name};

#elseif( $javaType.startsWith("IObject"))## Special case of the previous------------
#set( $javaType = "omero.model.IObject")
#set( $getter = "(omero.model.IObject) this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::model::IObject")
#set( $cppType = "${iceType}Ptr")
#set( $copyMethod = "this.${fieldName} = ($javaType) mapper.findTarget(source.get${PropertyName}());" );
[$Ice]       omero::model::IObject ${property.name};

#elseif( $javaType.startsWith("java.lang.Boolean"))## -------------------------------
#set( $javaType = "omero.RBool");
#set( $iceType   = "omero::RBool" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : rbool(source.get${PropertyName}());" );
[$Ice]       omero::RBool ${property.name};

#elseif( $javaType.startsWith("java.lang.Integer"))
#set( $javaType = "omero.RInt");
#set( $iceType   = "omero::RInt" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : rint(source.get${PropertyName}());" );
[$Ice]       omero::RInt ${property.name};

#elseif( $javaType.startsWith("java.lang.Long"))
#set( $javaType = "omero.RLong");
#set( $iceType   = "omero::RLong" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : rlong(source.get${PropertyName}());" );
[$Ice]       omero::RLong ${property.name};

#elseif( $javaType.startsWith("java.lang.Double"))
#set( $javaType = "omero.RDouble");
#set( $iceType   = "omero::RDouble" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : rdouble(source.get${PropertyName}());" );
[$Ice]       omero::RDouble ${property.name};

#elseif( $javaType.startsWith("java.lang.Float"))
#set( $javaType = "omero.RFloat");
#set( $iceType   = "omero::RFloat" )
#set( $cppType   = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : rfloat(source.get${PropertyName}());" );
[$Ice]       omero::RFloat ${property.name};

#elseif( $javaType.equals("byte[]"))
#set( $javaType = "byte[]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "Ice::ByteSeq")
#set( $cppType = "Ice::ByteSeq")
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}();")
[$Ice]       Ice::ByteSeq ${property.name};

#elseif( $javaType.equals("String[]"))
#set( $javaType = "String[]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "Ice::StringSeq")
#set( $cppType = "Ice::StringSeq")
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}();")
[$Ice]       Ice::StringSeq ${property.name};

#elseif( $javaType.equals("java.util.List<String>"))
#set( $javaType = "String[]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::api::StringArray")
#set( $cppType = "omero::api::StringArray")
#set( $copyMethod = "this.${fieldName} = (source.get${PropertyName}() == null ? null : source.get${PropertyName}().toArray(new String[]{}));" )
[$Ice]       omero::api::StringArray ${property.name};

#elseif( $javaType.equals("java.util.List<String[]>"))
#set( $javaType = "String[][]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "omero::api::StringArrayArray")
#set( $cppType = "omero::api::StringArrayArray")
#set( $copyMethod = "this.${fieldName} = (source.get${PropertyName}() == null ? null : source.get${PropertyName}().toArray(new String[][]{}));" )
[$Ice]       omero::api::StringArrayArray ${property.name};

#elseif( $javaType.equals("double[]"))
#set( $javaType = "double[]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "Ice::DoubleSeq")
#set( $cppType = "Ice::DoubleSeq")
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}();")
[$Ice]       Ice::DoubleSeq ${property.name};

#elseif( $javaType.equals("int[]"))
#set( $javaType = "int[]")
#set( $getter = "this.$property.name" )
#set( $setter = "${property.name}")
#set( $iceType = "Ice::IntSeq")
#set( $cppType = "Ice::IntSeq")
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}();")
[$Ice]       Ice::IntSeq ${property.name};

#elseif( $javaType.startsWith("long")) ## for Permissions
#set( $javaType = "Long" )
#set( $getter   = "new Long(this.$property.name)" )
#set( $setter = "(${property.name} == null) ? 0 : this.$property.name == ${property.name}.longValue()")
#set( $iceType = "long" )
#set( $cppType = "long" )
#set( $copyMethod = "ome.util.Utils.internalForm(source)" )
[$Ice]       long ${property.name};

#elseif( $javaType.startsWith("java.util.Map") )
#set( $javaType = "java.util.Map<String, omero.RString>" )
#set( $copyMethod = "this.${fieldName} = ($javaType) mapper.findMap(source.get${PropertyName}());" );
[$Ice]       dictionary ${property.name};

#elseif( $javaType.startsWith("java.sql.Timestamp")) ## for Event
#set( $javaType = "omero.RTime");
#set( $iceType = "omero::RTime" )
#set( $cppType = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : rtime(source.get${PropertyName}().getTime() );" );
[$Ice]       omero::RTime ${property.name};

#elseif( $property.class.name == "ome.dsl.MapField" )
#set( $javaType = "java.util.List<omero.model.NamedValue>");
#set( $iceType = "omero::api::NamedValueList" )
#set( $cppType = "${iceType}" )
#set( $copyMethod = "this.${fieldName} = omero.util.IceMapper.convertNamedValueList(source.get${PropertyName}());" );
[$Ice]       omero::api::NamedValueList ${property.name};
[$Ice]       omero::api::StringStringMap get${PropertyName}AsMap();

#elseif( $javaType.startsWith("java.lang.String")) ## for Event
#set( $javaType = "omero.RString");
#set( $iceType = "omero::RString" )
#set( $cppType = "${iceType}Ptr" )
#set( $copyMethod = "this.${fieldName} = source.get${PropertyName}() == null ? null : rstring(source.get${PropertyName}() );" );
[$Ice]       omero::RString ${property.name};

#else
[$all]...ERROR...$javaType unknown.

#end##JAVA_TYPE

Here we only add the getters and setters to Ice if this is not a collection,
since slice has no concept of visibility. Instead, the special collection
methods below will be used for access.

#if( ! $property.one2Many )
[$Ice]       $iceType get${PropertyName}();
[$Ice]       void set${PropertyName}($iceType the${PropertyName});
#end

ASSOCIATION TYPES BLOCK:
=====================================================================================================

#set( $hasSet  = false )
#set( $hasLink = false )
#set( $Col = "NOT")
#set( $JAV_CURRENT_COLL = "")
#set( $CPP_CURRENT_COLL = "")
#set( $HDR_CURRENT_COLL = "")
#set( $PYC_CURRENT_COLL = "")
#if( $property.one2Many )
#set( $hasSet  = $property.one2Many)
#set( $Col = $Ice )
#set( $JAV_CURRENT_COLL = $JAV_CURRENT)
#set( $CPP_CURRENT_COLL = $CPP_CURRENT_UNUSED)
#set( $HDR_CURRENT_COLL = $HDR_CURRENT)
#set( $PYC_CURRENT_COLL = $PYC_CURRENT)
#end
#if( $property.class.name.equals("ome.dsl.ChildLink") || $property.class.name.equals("ome.dsl.ParentLink"))
#set( $hasLink = true )
#end

#set( $access = "protected" )
#set( $unloadIfIsSet = "${property.Name}Loaded = false;")
#if( !$hasSet && !$hasLink)
#set( $access = "public" )
#set( $unloadIfIsSet = "");
#end

Unload
------

[$Col]       /*
[$Col]        * Unloads the ${property.name} collection. Any access to this
[$Col]        * collection will throw an omero.UnloadedCollectionException.
[$Col]        *
[$Col]        * See sizeOf${PropertyName}() on how to test for unloaded collections.
[$Col]        * See reload${PropertyName}() on how to reset the value.
[$Col]        *
[$Col]        */
[$Col]       void unload${PropertyName}();
[$jav]       public void unload${PropertyName}($JAV_CURRENT_COLL) {
[$jav]           ${unloadIfIsSet}
[$jav]           ${fieldName} = null;
[$jav]       }
[$hdr]       virtual void unload${PropertyName}($HDR_CURRENT_COLL);
[$cpp]       void ${Pojo}I::unload${PropertyName}($CPP_CURRENT_COLL) {
[$cpp]           ${unloadIfIsSet}
#if( $property.class.name == "ome.dsl.MapField" )
[$cpp]           ${fieldName} = $cppType();
#else
[$cpp]           ${fieldName} = static_cast<$cppType>(0);
#end
[$cpp]       }
[$pyc]       def unload${PropertyName}(self, $PYC_CURRENT_COLL):
[$pyc]           self._${property.name}Loaded = False
[$pyc]           self._${fieldName} = None;
[$pyc]
Original accessors: will have their visibility reduced if
the special set methods are added.

[$jav]       $access $javaType get${property.nameCapped}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           return $getter;
[$jav]       }
[$jav]
#if( $property.class.name == "ome.dsl.MapField" )
[$jav]       public java.util.Map<String, String> get${property.nameCapped}AsMap($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           java.util.Map<String, String> rv = new java.util.HashMap<String, String>();
[$jav]           for (omero.model.NamedValue nv : $getter) {
[$jav]               if (nv != null) {
[$jav]                   rv.put(nv.name, nv.value);
[$jav]               }
[$jav]           }
[$jav]           return rv;
[$jav]       }
[$jav]
#end
[$jav]       $access void set${PropertyName}($javaType $property.name, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           this.$fieldName = $setter;
[$jav]           $unloadedJava
[$jav]       }
[$jav]
[$jav]       private void copy${PropertyName}($type.id source, omero.util.IceMapper mapper) {
[$jav]           $copyMethod
#if ($property.one2Many && $property.isLink && !$property.actualTarget.global)
[$jav]           this.${property.name}CountPerOwner = source.get${property.nameCapped}CountPerOwner();
#end
[$jav]       }
[$jav]
[$jav]       private void fill${PropertyName}($type.id target, omero.util.IceMapper mapper) {
#if( $type.id.equals("ome.model.internal.Permissions") )
[$jav]             ome.model.internal.Permissions p = ome.util.Utils.toPermissions((Long)this.getPerm1());
[$jav]             target.revokeAll(ome.model.internal.Permissions.EMPTY); // AND
[$jav]             target.grantAll(p); // OR

#elseif( $property.one2Many )
## If this is the case, we can't use the accessor and have to use a generated method

[$jav]             if (this.${propLoaded}) {

ticket:684 This is necessary to map back and forth from sets.
#set( $fieldType = $property.fieldType.replaceAll("[<].*[>]",""))
[$jav]               target.putAt( $STATICFIELDNAME, mapper.reverse( this.${fieldName}, ${fieldType}.class ));
[$jav]             } else {
[$jav]               target.putAt( $STATICFIELDNAME, null );
[$jav]             }

#elseif( $javaType.startsWith("omero.R") )
[$jav]             try {
[$jav]                 target.set${PropertyName}( (${property.fieldType}) mapper.fromRType( this.get${PropertyName}() ));
[$jav]             } catch (omero.ApiUsageException aue) {
[$jav]                 throw new omero.ClientError(aue.message);
[$jav]             }
#elseif( $javaType.startsWith("ome") )
[$jav]             target.putAt($STATICFIELDNAME, mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("IObject") )
[$jav]             target.set${PropertyName}( mapper.reverse( (ome.model.ModelBased) this.get${PropertyName}() ) );

#elseif( $javaType.startsWith("long"))
 ----------------> ERROR
#elseif( $javaType.startsWith("String[]"))
[$jav]             target.set${PropertyName}( this.get${PropertyName}() == null ? null : java.util.Arrays.asList(this.get${PropertyName}() ));
#elseif( $javaType.startsWith("java.util.Map"))
[$jav]             target.set${PropertyName}( omero.util.IceMapper.reverseStringStringMap(this.get${PropertyName}() ));
#elseif( $property.class.name == "ome.dsl.MapField" )
[$jav]             target.set${PropertyName}( omero.util.IceMapper.reverseNamedList(this.get${PropertyName}() ));
#else
[$jav]             target.set${PropertyName}( this.get${PropertyName}() );
#end
[$jav]       }
[$jav]


#if($access == "protected" )
[$hdr]     protected:
#end
[$hdr]       virtual $cppType get${property.nameCapped}($HDR_CURRENT);
[$hdr]       virtual void set${PropertyName}(const $cppType& _$property.name, $HDR_CURRENT);
#if( $property.class.name == "ome.dsl.MapField" )
[$hdr]       virtual omero::api::StringStringMap get${property.nameCapped}AsMap($HDR_CURRENT);
#end
#if($access == "protected" )
[$hdr]     public:
#end

[$cpp]       $cppType ${PojoI}::get${property.nameCapped}($CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           return ${open}${fieldName}${close};
[$cpp]       }
[$cpp]
[$cpp]       void ${PojoI}::set${PropertyName}(const ${cppType}& _$property.name, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           $fieldName = $!{prefix}_${property.name}$!{suffix};
[$cpp]           $unloadedCpp
[$cpp]       }
#if( $property.class.name == "ome.dsl.MapField" )
[$cpp]       omero::api::StringStringMap ${PojoI}::get${property.nameCapped}AsMap($CPP_CURRENT_UNUSED) {
[$cpp]           omero::api::StringStringMap rv;
[$cpp]           for (omero::api::NamedValueList::const_iterator it = ${fieldName}.begin(); it != ${fieldName}.end(); ++it) {
[$cpp]               omero::model::NamedValuePtr target = *it;
[$cpp]               if (target) {
[$cpp]                   rv[target->name] = target->value;
[$cpp]               }
[$cpp]           }
[$cpp]           return rv;
[$cpp]       }
#end

#set($pyaccess = "")
#if($property.one2Many)
#set($pyaccess = "_")
#end

It's unclear if these methods are useful at all, but for the moment lowering their
"visibility" to make __getattr__ logic work properly.

[$pyc]       def ${pyaccess}get${property.nameCapped}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           return self._${fieldName}
[$pyc]
[$pyc]       def ${pyaccess}set${PropertyName}(self, _${property.name}, $PYC_CURRENT, wrap=False):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if wrap and self._field_info.${fieldName}.wrapper is not None:
[$pyc]               if _${property.name} is not None:
[$pyc]                   _${property.name} = self._field_info.${fieldName}.wrapper(_${property.name})
[$pyc]           self._${fieldName} = _${property.name}
[$pyc]           $unloadedPython
[$pyc]
#if( $property.class.name == "ome.dsl.MapField" )
[$pyc]       def ${pyaccess}get${property.nameCapped}AsMap(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           rv = dict()
[$pyc]           for nv in self._${property.name}:
[$pyc]               if nv is not None:
[$pyc]                   rv[nv.name] = nv.value
[$pyc]           return rv
[$pyc]
#end


One-to-many extras:
======================================================================================
##  (copied from dsl/resources/ome/dsl/object.vm):
##  A one-to-many property represents a set that is contained by this entity.
##  These methods represent our handling of Hibernate's "inverse" sets
##  which do not act as expected with regards to getters & setters.
##
##  To prevent users from making mistakes like not properly setting both
##  sides of a relationship, these fields are hidden, and only accessible via
##  the following methods. Methods fall into several categories:
##    (A) general
##    (B) list-only
##    (C) link-based
##
##  (A) General one-to-many code
##  ----------------------------
##

#if( $hasSet || $hasLink )

isXLoaded ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The isXLoaded checks are not present in the ome.model classses
since we can use the nullness of the Java reference to check for
that. In Ice, we'd have to use an RCollection to use nullness,
which would take away our type safety. Instead, we add a boolean
field for every sequence. NOTE: These methods may not be needed
and instead sizeOf would suffice.

[$jav]       public boolean is${PropertyName}Loaded() {
[$jav]           return ${propLoaded};
[$jav]       }
[$hdr]       virtual bool is${PropertyName}Loaded();
[$cpp]       bool ${PojoI}::is${PropertyName}Loaded( ) {
[$cpp]           return ${propLoaded};
[$cpp]       }
[$pyc]       def is${PropertyName}Loaded(self):
[$pyc]           return self._${propLoaded}
[$pyc]

sizeOf ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[$Ice]       int sizeOf${PropertyName}();
[$jav]       public int sizeOf${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) return -1;
[$jav]           return ${fieldName}.size();
[$jav]       }
[$hdr]       virtual Ice::Int sizeOf${PropertyName}($HDR_CURRENT);
[$cpp]       Ice::Int ${PojoI}::sizeOf${PropertyName}($CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) return -1;
[$cpp]           return static_cast<Ice::Int>(${fieldName}.size());
[$cpp]       }
[$pyc]       def sizeOf${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: return -1
[$pyc]           return len(self._${fieldName})
[$pyc]

Copy ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[$Ice]       $iceType copy${PropertyName}();
[$jav]       public $javaType copy${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException{
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List<$javaType> result = new ArrayList(${fieldName});
[$jav]           return result;
[$jav]       }
[$pyc]       def copy${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return list(self._${fieldName})
[$pyc]
             Here we don't have a vector<$cppType> since the type is typedef'd
[$hdr]       virtual $cppType copy${PropertyName}($HDR_CURRENT);
[$cpp]       $cppType ${PojoI}::copy${PropertyName}($CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType result(${fieldName}.size());
[$cpp]           std::copy(${fieldName}.begin(), ${fieldName}.end(), result.begin());
[$cpp]           return result;
[$cpp]       }

Iterators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Iterators are language-specific since there's no slice concept
for them. Therefore, to use these, developers must down-cast.

[$Ice]       // See language-specific iterator methods
[$jav]       public Iterator iterate${PropertyName}() throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           return ${fieldName}.iterator();
[$jav]       }
[$hdr]       virtual $cppType::iterator begin${PropertyName}();
[$hdr]       virtual $cppType::iterator end${PropertyName}();
[$cpp]       $cppType::iterator ${PojoI}::begin${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.begin();
[$cpp]       }
[$cpp]       $cppType::iterator ${PojoI}::end${PropertyName}(){
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.end();
[$cpp]       }
[$pyc]       def iterate${PropertyName}(self):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return iter(self._${fieldName})
[$pyc]

#end


------------------------------------------------------------
Because of the ice inheritance hierarchy, we must use direct
field access on several methods below.
------------------------------------------------------------

Set modifications:

#if( $hasSet )
#set( $inverse = $property.inverse )
#set( $inverselength = $inverse.length() )
#set( $Inverse = "${inverse.substring(0,1).toUpperCase()}${inverse.substring(1,$inverselength)}" )

add single

[$Ice]       void add${property.fieldName}(${property.shortType} target);
[$jav]       public void add${property.fieldName}(${property.shortType} target, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.add( target );
[$jav]           target.set$Inverse( this );
[$jav]       }
[$pyc]       def add${property.fieldName}(self, target, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.append( target );
[$pyc]           target.set$Inverse( self )
[$pyc]
[$hdr]       virtual void add${property.fieldName}(const ${property.shortType}Ptr& target, $HDR_CURRENT);
[$cpp]       void ${PojoI}::add${property.fieldName}(const ${property.shortType}Ptr& target, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${fieldName}.push_back( target );
[$cpp]           target->set$Inverse(this);
[$cpp]       }

addAll set

[$Ice]       /*
[$Ice]        * Adds all the members of the ${iceType} sequence to
[$Ice]        * the ${fieldName} field.
[$Ice]        */
[$Ice]       void addAll${property.fieldName}Set(${iceType} targets);
[$jav]       public void addAll${property.fieldName}Set($javaType<${property.shortType}> targets, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.addAll( targets );
[$jav]           for( ${property.shortType} target : targets) {
[$jav]               target.set$Inverse( this );
[$jav]           }
[$jav]       }
[$pyc]       def addAll${property.fieldName}Set(self, targets, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if  not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.extend( targets )
[$pyc]           for target in targets:
[$pyc]               target.set$Inverse( self )
[$pyc]
[$hdr]       virtual void addAll${property.fieldName}Set(const ${cppType}& targets, $HDR_CURRENT);
[$cpp]       void ${PojoI}::addAll${property.fieldName}Set(const ${cppType}& targets, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator loc = ${fieldName}.end();
[$cpp]           $cppType::const_iterator beg = targets.begin();
[$cpp]           $cppType::const_iterator end = targets.end();
[$cpp]           ${fieldName}.insert(loc,beg,end);
[$cpp]           for ($cppType::const_iterator it = targets.begin(); it != targets.end(); ++it) {
[$cpp]               ${property.shortType}Ptr target = *it;
[$cpp]               target->set$Inverse( this );
[$cpp]           }
[$cpp]       }

remove single

[$Ice]       void remove${property.fieldName}(${property.shortType} theTarget);
[$jav]       public void remove${property.fieldName}(${property.shortType} target, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.remove( target );
[$jav]           target.set$Inverse( null );
[$jav]       }
[$pyc]       def remove${property.fieldName}(self, target, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.remove( target )
[$pyc]           target.set$Inverse( None )
[$pyc]
[$hdr]       virtual void remove${property.fieldName}(const ${property.shortType}Ptr& target, $HDR_CURRENT);
[$cpp]       void ${PojoI}::remove${property.fieldName}(const ${property.shortType}Ptr& target, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${fieldName}.begin(),
[$cpp]               ${fieldName}.end(),
[$cpp]               omero::ContainsPointer<${property.shortType}Ptr>(target));
[$cpp]           ${fieldName}.erase(it,${fieldName}.end());
[$cpp]           target->set$Inverse(static_cast<${PojoI}Ptr>(0));
[$cpp]       }

removeAll multiple

[$Ice]       /*
[$Ice]        * Removes all the members of the ${iceType} sequence from
[$Ice]        * the ${fieldName} field.
[$Ice]        */
[$Ice]       void removeAll${property.fieldName}Set(${iceType} targets);
[$jav]       public void removeAll${property.fieldName}Set($javaType<${property.shortType}> targets, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           for( ${property.shortType} elt : targets) {
[$jav]               elt.set$Inverse( null );
[$jav]               ${fieldName}.remove( elt );
[$jav]           }
[$jav]       }
[$pyc]       def removeAll${property.fieldName}Set(self, targets, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           for elt in targets:
[$pyc]               elt.set$Inverse( None )
[$pyc]               self._${fieldName}.remove( elt )
[$pyc]
[$hdr]       virtual void removeAll${property.fieldName}Set(const ${cppType}& targets, $HDR_CURRENT);
[$cpp]       void ${PojoI}::removeAll${property.fieldName}Set(const ${cppType}& targets, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${cppType}::iterator end = ${fieldName}.end();
[$cpp]           ${cppType}::iterator removed = std::remove_if(
[$cpp]               ${fieldName}.begin(), end,
[$cpp]               omero::VectorContainsPointer<${property.shortType}Ptr>(targets));
[$cpp]           ${cppType}::iterator beg(removed);
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->set$Inverse(static_cast<${PojoI}Ptr>(0));
[$cpp]           }
[$cpp]           ${fieldName}.erase(removed,end);
[$cpp]       }

clear

[$Ice]       void clear${PropertyName}();
[$jav]       public void clear${PropertyName}($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           for( ${property.shortType} elt : (Collection<${property.shortType}>)${fieldName}) {
[$jav]               elt.set$Inverse( null );
[$jav]           }
[$jav]           ${fieldName}.clear();
[$jav]       }
[$pyc]       def clear${PropertyName}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           for elt in self._${fieldName}:
[$pyc]               elt.set$Inverse( None )
[$pyc]           self._${fieldName} = list()
[$pyc]
[$hdr]       virtual void clear${PropertyName}($HDR_CURRENT);
[$cpp]       void ${PojoI}::clear${PropertyName}($CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $cppType::iterator beg = ${fieldName}.begin();
[$cpp]           $cppType::iterator end = ${fieldName}.end();
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->set$Inverse(static_cast<${PojoI}Ptr>(0));
[$cpp]           }
[$cpp]           ${fieldName}.clear();
[$cpp]       }

reload : allows reloading a given collection for another instance.
Here we have to use prop.actualType.shortName rather than Prop
because the passed in object must match the type of the (abstract)
super class where the property was defined.

[$Ice]
[$Ice]       /*
[$Ice]        * Allows reloading the protected ${property.name} collection
[$Ice]        * from another instance of ${ActualPojo}. The argument's collection
[$Ice]        * will be unloaded and all member entities will have their
[$Ice]        * inverse property altered.
[$Ice]        *
[$Ice]        * The argument's id must match and it's update id must be present and
[$Ice]        * greater than or equal to that of the current object.
[$Ice]        */
[$Ice]       void reload${PropertyName}(${ActualPojo} toCopy);

[$jav]       public void reload${PropertyName}(${ActualPojo} toCopy, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (${propLoaded}) {
[$jav]              throw new omero.ClientError("Cannot reload active collection: ${fieldName}");
[$jav]           }
[$jav]           if (toCopy == null) {
[$jav]              throw new omero.ClientError("Argument cannot be null");
[$jav]           }
[$jav]           if (toCopy.getId().getValue() != getId().getValue()) {
[$jav]              throw new omero.ClientError("Argument must have the same id as this instance");
[$jav]           }
#if( ! $type.immutable )
[$jav]           if (toCopy.getDetails().getUpdateEvent().getId().getValue() < getDetails().getUpdateEvent().getId().getValue()) {
[$jav]              throw new omero.ClientError("Argument may not be older than this instance");
[$jav]           }
#end
[$jav]           Collection<${property.shortType}> copy = toCopy.copy${PropertyName}(); // May also throw
[$jav]           for( ${property.shortType} elt : copy) {
[$jav]               elt.set$Inverse( this );
[$jav]           }
[$jav]           ${fieldName} = new ArrayList<${property.shortType}>(copy);
[$jav]           toCopy.unload${PropertyName}();
[$jav]           ${propLoaded} = true;
[$jav]       }
[$pyc]       def reload${PropertyName}(self, toCopy, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if self._${propLoaded}:
[$pyc]               raise omero.ClientError("Cannot reload active collection: ${fieldName}")
[$pyc]           if not toCopy:
[$pyc]               raise omero.ClientError("Argument cannot be null")
[$pyc]           if toCopy.getId().getValue() != self.getId().getValue():
[$pyc]              raise omero.ClientError("Argument must have the same id as this instance")
#if( ! $type.immutable )
[$pyc]           if toCopy.getDetails().getUpdateEvent().getId().getValue() < self.getDetails().getUpdateEvent().getId().getValue():
[$pyc]              raise omero.ClientError("Argument may not be older than this instance")
#end
[$pyc]           copy = toCopy.copy${PropertyName}() # May also throw
[$pyc]           for elt in copy:
[$pyc]               elt.set$Inverse( self )
[$pyc]           self._${fieldName} = copy
[$pyc]           toCopy.unload${PropertyName}()
[$pyc]           self._${propLoaded} = True
[$pyc]
[$hdr]       virtual void reload${PropertyName}(const ${ActualPojo}Ptr& toCopy, $HDR_CURRENT);
[$cpp]       void ${PojoI}::reload${PropertyName}(const ${ActualPojo}Ptr& toCopy, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (${propLoaded}) {
[$cpp]               throw omero::ClientError(__FILE__,__LINE__,"Cannot reload active collection: ${fieldName}");
[$cpp]           }
[$cpp]           if (!toCopy) {
[$cpp]               throw omero::ClientError(__FILE__,__LINE__,"Argument cannot be null");
[$cpp]           }
[$cpp]           if (toCopy->getId()->getValue() != getId()->getValue()) {
[$cpp]              throw omero::ClientError(__FILE__,__LINE__,"Argument must have the same id as this instance");
[$cpp]           }
#if( ! $type.immutable )
[$cpp]           if (toCopy->getDetails()->getUpdateEvent()->getId()->getValue() < getDetails()->getUpdateEvent()->getId()->getValue()) {
[$cpp]              throw omero::ClientError(__FILE__,__LINE__,"Argument may not be older than this instance");
[$cpp]           }
#end
[$cpp]           ${cppType} copy = toCopy->copy${PropertyName}(); // May also throw
[$cpp]           $cppType::iterator beg = copy.begin();
[$cpp]           $cppType::iterator end = copy.end();
[$cpp]           for(; beg != end; beg++) {
[$cpp]               (*beg)->set$Inverse( this );
[$cpp]           }
[$cpp]           ${fieldName} = copy;
[$cpp]           toCopy->unload${PropertyName}();
[$cpp]           ${propLoaded} = true;
[$cpp]       }

(B) List Modifications
===============================================================

#if( ${property.ordered} )
[$Ice]       ${property.shortType} get${property.shortType}(int index);
[$Ice]       ${property.shortType} set${property.shortType}(int index, ${property.shortType} theElement);
[$Ice]       ${property.shortType} getPrimary${property.shortType}();
[$Ice]       ${property.shortType} setPrimary${property.shortType}(${property.shortType} theElement);

[$jav]       public ${property.shortType} get${property.shortType}(int index, $JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           return ${fieldName}.get(index);
[$jav]       }
[$jav]
[$jav]       public ${property.shortType} set${property.shortType}(int index, ${property.shortType} element, $JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${property.shortType} old = ${fieldName}.set(index, element);
[$jav]           if (element != null && element.isLoaded()) {
[$jav]               element.set${property.inverseCapped}( this );
[$jav]           }
[$jav]           return old;
[$jav]       }
[$jav]
[$jav]       public ${property.shortType} getPrimary${property.shortType}($JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           return ${fieldName}.get(0);
[$jav]       }
[$jav]
[$jav]       public ${property.shortType} setPrimary${property.shortType}(${property.shortType} element, $JAV_CURRENT) throws IndexOutOfBoundsException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           int index = ${fieldName}.indexOf(element);
[$jav]           ${property.shortType} old = ${fieldName}.get(0);
[$jav]           ${fieldName}.set(index, old);
[$jav]           ${fieldName}.set(0, element);
[$jav]           return old;
[$jav]       }
[$jav]

#set( $CPPRETURNTYPE = "${property.shortType}Ptr")
[$hdr]       virtual $CPPRETURNTYPE get${property.shortType}(int index, $HDR_CURRENT);
[$cpp]       $CPPRETURNTYPE ${PojoI}::get${property.shortType}(int index, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.at(index); // throws out_of_range
[$cpp]       }
[$cpp]
[$hdr]       virtual $CPPRETURNTYPE set${property.shortType}(int index, const ${property.shortType}Ptr& element, $HDR_CURRENT);
[$cpp]       $CPPRETURNTYPE ${PojoI}::set${property.shortType}(int index, const ${property.shortType}Ptr& element, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           $CPPRETURNTYPE old = ${fieldName}.at(index); // throws out_of_range
[$cpp]           ${fieldName}[index] = element;
[$cpp]           if (element && element->isLoaded()) {
[$cpp]               element->set${property.inverseCapped}( this );
[$cpp]           }
[$cpp]           return old;
[$cpp]       }
[$cpp]
[$hdr]       virtual $CPPRETURNTYPE getPrimary${property.shortType}($HDR_CURRENT);
[$cpp]       $CPPRETURNTYPE ${PojoI}::getPrimary${property.shortType}($CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           return ${fieldName}.at(0); // throws out_of_range
[$cpp]       }
[$cpp]
[$hdr]       virtual $CPPRETURNTYPE setPrimary${property.shortType}(const ${property.shortType}Ptr& element, $HDR_CURRENT);
[$cpp]       $CPPRETURNTYPE ${PojoI}::setPrimary${property.shortType}(const ${property.shortType}Ptr& element, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           int index = omero::indexOf(${fieldName}, element);
[$cpp]           $CPPRETURNTYPE old = ${fieldName}.at(0); // throws out_of_range
[$cpp]           $CPPRETURNTYPE elt = ${fieldName}.at(index); // throws out_of_range
[$cpp]           ${fieldName}[index] = old;
[$cpp]           ${fieldName}[0] = element;
[$cpp]           return old;
[$cpp]       }
[$cpp]

[$pyc]       def get${property.shortType}(self, index, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return self._${fieldName}[index]
[$pyc]
[$pyc]       def set${property.shortType}(self, index, element, $PYC_CURRENT, wrap=False):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           old = self._${fieldName}[index]
[$pyc]           if wrap and self._field_info.${fieldName}.wrapper is not None:
[$pyc]               if element is not None:
[$pyc]                   element = self._field_info.${fieldName}.wrapper(_${property.name})
[$pyc]           self._${fieldName}[index] =  element
[$pyc]           if element is not None and element.isLoaded():
[$pyc]               element.set${property.inverseCapped}( self )
[$pyc]           return old
[$pyc]
[$pyc]       def getPrimary${property.shortType}(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           return self._${fieldName}[0]
[$pyc]
[$pyc]       def setPrimary${property.shortType}(self, element, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           index = self._${fieldName}.index(element)
[$pyc]           old = self._${fieldName}[0]
[$pyc]           self._${fieldName}[index] = old
[$pyc]           self._${fieldName}[0] = element
[$pyc]           return old
[$pyc]
#end##property.ordered


(C) Link Modifications
===============================================================

#if( $hasLink )

Here our "elements" from the above are the links which themselves
have linked elements.

#if($property.class.name == "ome.dsl.ChildLink" )
#set( $order = "this, addition" )
#set( $next = "getParent()" )
#set( $other = "getChild()" )
#elseif($property.class.name == "ome.dsl.ParentLink")
#set( $order = "addition, this" )
#set( $next = "getChild()" )
#set( $other = "getParent()" )
#end
#set( $bidir = $property.bidirectional )
#set( $pyorder = $order.replaceAll("this","self"))

COUNTS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#if( !$property.actualTarget.global )
#set( $GETCOUNTMETHOD = "get${property.nameCapped}CountPerOwner" )
#set( $GETCOUNTVALUE  = "${property.name}CountPerOwner" )
[$Ice]       omero::sys::CountMap $GETCOUNTMETHOD();
[$jav]       public java.util.Map<Long, Long> $GETCOUNTMETHOD($JAV_CURRENT) {
[$jav]           return this.$GETCOUNTVALUE;
[$jav]       }
[$jav]
[$hdr]       virtual omero::sys::CountMap $GETCOUNTMETHOD($HDR_CURRENT);
[$cpp]       omero::sys::CountMap ${PojoI}::$GETCOUNTMETHOD($CPP_CURRENT_UNUSED) {
[$cpp]           return $GETCOUNTVALUE;
[$cpp]       }
[$pyc]       def $GETCOUNTMETHOD(self, $PYC_CURRENT):
[$pyc]           return self._$GETCOUNTVALUE
[$pyc]
#end

ADD ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#set( $ADD2METHOD = "add${property.shortType}ToBoth")

[$Ice]       ${property.shortType} link${property.targetName}(${property.shortTarget} addition);
[$jav]       public ${property.shortType} link${property.targetName}(${property.shortTarget} addition, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${property.shortType}I link = new ${property.shortType}I();
[$jav]           link.link( ${order} );
[$jav]           $ADD2METHOD( link, true );
[$jav]           return link;
[$jav]       }
[$pyc]       def link${property.targetName}(self, addition, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           link = _omero_model.${property.shortType}I()
[$pyc]           link.link( ${pyorder} );
[$pyc]           self.$ADD2METHOD( link, True )
[$pyc]           return link
[$pyc]
[$hdr]       virtual ${property.shortType}Ptr link${property.targetName}(const ${property.shortTarget}Ptr& addition, $HDR_CURRENT);
[$cpp]       ${property.shortType}Ptr ${PojoI}::link${property.targetName}(const ${property.shortTarget}Ptr& addition, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${property.shortType}Ptr link = new ${property.shortType}I();
[$cpp]           link->link( ${order} );
[$cpp]           $ADD2METHOD( link, true );
[$cpp]           return link;
[$cpp]       }

TODO: do we need to do link.parent = ...;

[$Ice]
[$Ice]       /*
[$Ice]        * Add the link to the current instance and if bothSides is true AND
[$Ice]        * the other side of the link is loaded, add the current instance to
[$Ice]        * it as well.
[$Ice]        */
[$Ice]       void $ADD2METHOD(omero::model::${property.shortType} link, bool bothSides);
[$jav]       public void $ADD2METHOD(${property.shortType} link, boolean bothSides, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.add( link );
#if($bidir)
TODO: Should we check for nulls in other?
[$jav]           if (bothSides && link.${other}.isLoaded() ) {
[$jav]               ((${property.shortTarget})link.${other}).$ADD2METHOD( link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def $ADD2METHOD(self, link, bothSides):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.append( link )
#if($bidir)
[$pyc]           if bothSides and link.${other}.isLoaded():
[$pyc]               link.${other}.$ADD2METHOD( link, False )
#end
[$pyc]
#if($bidir)
[$hdr]       virtual void $ADD2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $HDR_CURRENT);
[$cpp]       void ${PojoI}::$ADD2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $CPP_CURRENT_UNUSED) {
#else
[$hdr]       virtual void $ADD2METHOD(const ${property.shortType}Ptr& link, bool /*unused*/, $HDR_CURRENT);
[$cpp]       void ${PojoI}::$ADD2METHOD(const ${property.shortType}Ptr& link, bool /*unused*/, $CPP_CURRENT_UNUSED) {
#end
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           ${fieldName}.push_back( link );
#if($bidir)
[$cpp]           if (bothSides && link->${other}->isLoaded() ) {
[$cpp]               ${property.shortTarget}Ptr::dynamicCast(link->${other})->$ADD2METHOD( link, false );
[$cpp]           }
#end
[$cpp]       }

FIND
================================

[$Ice]       $iceType find${property.shortType}(${property.shortTarget} removal);
[$jav]       public List<$property.shortType> find${property.shortType}(${property.shortTarget} removal, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List result = new ArrayList();
[$jav]           for( $property.shortType link : ${fieldName} ) {
[$jav]               if (link.${other} == removal) result.add(link);
[$jav]           }
[$jav]           return result;
[$jav]       }
[$pyc]       def find${property.shortType}(self, removal, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           result = list()
[$pyc]           for link in self._${fieldName}:
[$pyc]               if link.${other} == removal: result.append(link)
[$pyc]           return result
[$pyc]
[$hdr]       virtual $cppType find${property.shortType}(const ${property.shortTarget}Ptr& removal, $HDR_CURRENT);
[$cpp]       $cppType ${PojoI}::find${property.shortType}(const ${property.shortTarget}Ptr& removal, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           std::vector<${property.shortType}Ptr> result;
[$cpp]           $cppType::iterator beg = begin${PropertyName}();
[$cpp]           $cppType::iterator end = end${PropertyName}();
[$cpp]           while (beg != end) {
[$cpp]               if ((*beg)->${other} == removal) result.push_back( *beg );
[$cpp]               ++beg;
[$cpp]           }
[$cpp]           return result;
[$cpp]       }

REMOVE
=======================================
#set( $REMOVE2METHOD = "remove${property.shortType}FromBoth")

#set( $removeLinkPredicate = "testRemove${property.targetName}From${PojoI}" )
[$cpp]
[$cpp]       struct $removeLinkPredicate {
[$cpp]
[$cpp]         const ${property.shortType}Ptr t;
[$cpp]         const bool bothSides;
[$cpp]         ${removeLinkPredicate}(const ${property.shortType}Ptr n, const bool b) : t(n), bothSides(b) {}
[$cpp]         bool operator()(${property.shortType}Ptr const& o) {
[$cpp]            if (o == t) {
#if($bidir)
[$cpp]                if (bothSides && t->${other}->isLoaded()){
[$cpp]                    o->${other}->$REMOVE2METHOD(t,false);
[$cpp]                }
#end
[$cpp]                return true;
[$cpp]            }
[$cpp]            return false;
[$cpp]         }
[$cpp]       };
[$cpp]

[$Ice]       void unlink${property.targetName}(${property.shortTarget} removal);
[$jav]       public void unlink${property.targetName}(${property.shortTarget} removal, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           List<$property.shortType> toRemove = find${property.shortType}(removal);
[$jav]           Iterator<$property.shortType> it = toRemove.iterator();
[$jav]           while( it.hasNext() ){
[$jav]               $REMOVE2METHOD( it.next(), true );
[$jav]           }
[$jav]       }

[$Ice]
[$Ice]       /*
[$Ice]        * Remove the link from the current instance and if bothSides is true AND
[$Ice]        * the other side of the link is loaded, remove the current instance from
[$Ice]        * it as well.
[$Ice]        */
[$Ice]       void $REMOVE2METHOD(omero::model::${property.shortType} link, bool bothSides);
[$jav]       public void $REMOVE2METHOD(${property.shortType} link, boolean bothSides, $JAV_CURRENT  ) throws omero.UnloadedEntityException, omero.UnloadedCollectionException {
[$jav]           errorIfUnloaded();
[$jav]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$jav]           ${fieldName}.remove( link );
#if($bidir)
[$jav]           if (bothSides && link.${other}.isLoaded()) {
[$jav]               ((${property.shortTarget})link.${other}).$REMOVE2METHOD(link, false );
[$jav]           }
#end
[$jav]       }
[$pyc]       def unlink${property.targetName}(self, removal, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           toRemove = self.find${property.shortType}(removal)
[$pyc]           for next in toRemove:
[$pyc]               self.$REMOVE2METHOD( next, True )
[$pyc]
[$pyc]       def $REMOVE2METHOD(self, link, bothSides, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self._${propLoaded}: self.throwNullCollectionException("${fieldName}")
[$pyc]           self._${fieldName}.remove( link )
#if($bidir)
[$pyc]           if bothSides and link.${other}.isLoaded():
[$pyc]               link.${other}.$REMOVE2METHOD(link, False)
#end
[$pyc]
[$hdr]       virtual void unlink${property.targetName}(const ${property.shortTarget}Ptr& removal, $HDR_CURRENT);
[$cpp]       void ${PojoI}::unlink${property.targetName}(const ${property.shortTarget}Ptr& removal, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           std::vector<${property.shortType}Ptr> toRemove = find${property.shortType}(removal);
[$cpp]           $cppType::iterator beg = toRemove.begin();
[$cpp]           $cppType::iterator end = toRemove.end();
[$cpp]           while (beg != end) {
[$cpp]             $REMOVE2METHOD( *beg, true );
[$cpp]             ++beg;
[$cpp]           }
[$cpp]       }
[$hdr]       virtual void $REMOVE2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $HDR_CURRENT);
[$cpp]       void ${PojoI}::$REMOVE2METHOD(const ${property.shortType}Ptr& link, bool bothSides, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           if (!${propLoaded}) throwNullCollectionException("${fieldName}");
[$cpp]           // predicate may do reverse side
[$cpp]           $cppType::iterator it = std::remove_if(
[$cpp]               ${fieldName}.begin(),
[$cpp]               ${fieldName}.end(),
[$cpp]               ${removeLinkPredicate}(link, bothSides));
[$cpp]           ${fieldName}.erase(it,${fieldName}.end());
[$cpp]       }

Linked Lists
==============================

[$Ice]       ${ActualPojo}Linked${property.targetName}Seq linked${property.targetName}List();
[$jav]        public List<${property.shortTarget}> linked${property.targetName}List($JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]            errorIfUnloaded();
[$jav]            if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$jav]            List<${property.shortTarget}> linked = new ArrayList<${property.shortTarget}>();
[$jav]            for (${property.shortType} link : ${fieldName}) {
[$jav]                linked.add( link.$other );
[$jav]            }
[$jav]            return linked;
[$jav]        }

[$hdr]        virtual ${ActualPojo}Linked${property.targetName}Seq linked${property.targetName}List($HDR_CURRENT);
[$cpp]        ${ActualPojo}Linked${property.targetName}Seq ${PojoI}::linked${property.targetName}List($CPP_CURRENT_UNUSED) {
[$cpp]            errorIfUnloaded();
[$cpp]            if (!${propLoaded}) throwNullCollectionException("${PropertyName}");
[$cpp]            ${ActualPojo}Linked${property.targetName}Seq linked;
[$cpp]            ${seqName}::iterator beg = ${fieldName}.begin();
[$cpp]            while (beg != ${fieldName}.end()) {
[$cpp]                ${property.shortType}Ptr link = *beg;
[$cpp]                linked.push_back( link->$other );
[$cpp]                beg++;
[$cpp]            }
[$cpp]            return linked;
[$cpp]        }

[$pyc]       def linked${property.targetName}List(self, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           if not self.${propLoaded}: self.throwNullCollectionException("${PropertyName}")
[$pyc]           linked = []
[$pyc]           for link in self._${fieldName}:
[$pyc]               linked.append( link.$other )
[$pyc]           return linked
[$pyc]


#end##End hasLink
#end##End hasSet
#end##End SPECIAL EXCEPTIONS

##################################################################
#end##FOREACH#####################################################
##################################################################

CLASS-LEVEL EXTRA METHODS BLOCK:
=====================================================================================================

#if($type.class.name.equals("ome.dsl.LinkType"))
#foreach( $prop in $type.classProperties)
#if($prop.class.name == "ome.dsl.LinkParent")
#set( $parent = $type.unqualify($prop.type) )
#elseif($prop.class.name == "ome.dsl.LinkChild")
#set( $child = $type.unqualify($prop.type) )
#end
#end##FOREACH

#if( ! $type.superclass )
[$ice]       void link(${parent} theParent, ${child} theChild);
#end
[$jav]       public void link(${parent} _parent, ${child} _child, $JAV_CURRENT) throws omero.UnloadedEntityException {
[$jav]           errorIfUnloaded();
[$jav]           setParent( _parent );
[$jav]           setChild( _child );
[$jav]       }
[$pyc]
[$pyc]       def link(self, _parent, _child, $PYC_CURRENT):
[$pyc]           self.errorIfUnloaded()
[$pyc]           self.setParent( _parent )
[$pyc]           self.setChild( _child )
[$pyc]
[$hdr]       virtual void link(const ${parent}Ptr& parent, const ${child}Ptr& child, $HDR_CURRENT);
[$cpp]       void ${PojoI}::link(const ${parent}Ptr& _parent, const ${child}Ptr& _child, $CPP_CURRENT_UNUSED) {
[$cpp]           errorIfUnloaded();
[$cpp]           setParent( _parent );
[$cpp]           setChild(  _child  );
[$cpp]       }
#end


COPYOBJECT BLOCK:
=====================================================================================================

[$jav]       /**
[$jav]        * Used by {@link omero.util.IceMapper} to inject an "ome.model" object into this
[$jav]        * "omero.model" object.
[$jav]        */
[$jav]       public void copyObject(ome.util.Filterable model, ome.util.ModelMapper _mapper) {
[$jav]            omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]            if (model instanceof ${type.id}) {
[$jav]                ${type.id} source = (${type.id}) model;
[$jav]                this.loaded = source.isLoaded();
[$jav]                Long id = (Long) mapper.findTarget( source.getId() );
[$jav]                this.setId( id == null ? null : rlong(id) );
[$jav]                // Following also copy counts, etc. if necessary
[$jav]                if (!source.isLoaded()) {
[$jav]                    this.unload();
[$jav]                } else {
#if( ! $type.immutable )
[$jav]             this.version = source.getVersion() == null ? null : rint( source.getVersion() );
#end
#foreach($property in $type.propertyClosure)
[$jav]                    this.copy${property.nameCapped}( source, mapper );
#end##FOREACH
[$jav]               }
[$jav]             } else {
[$jav]                throw new IllegalArgumentException(
[$jav]                  "${type.shortname} cannot copy from " +
[$jav]                  (model==null ? "null" : model.getClass().getName()));
[$jav]             }
[$jav]       }

FILLOBJECT BLOCK:
=====================================================================================================

[$jav]       /**
[$jav]        * Used by {@link omero.util.IceMapper} produce an "ome.model" object from this
[$jav]        * "omero.model" object.
[$jav]        */
[$jav]       public ome.util.Filterable fillObject(ome.util.ReverseModelMapper _mapper) {
[$jav]           omero.util.IceMapper mapper = (omero.util.IceMapper) _mapper;
[$jav]           $type.id target = new ${type.id}();
[$jav]           mapper.store(this, target);
[$jav]           if (!this.loaded) {
[$jav]             target.setId( id == null ? null : id.getValue() );
[$jav]             target.unload();
[$jav]           } else {
[$jav]             omero.RLong id = this.getId();
[$jav]             target.setId( id == null ? null : Long.valueOf(id.getValue()) ); // special property
#if( ! $type.immutable )
[$jav]             target.setVersion(  this.version == null ? null : this.version.getValue() );
#end
[$jav]
[$jav]             // Following also copy counts, etc. if necessary
#foreach($property in $type.propertyClosure)
[$jav]             this.fill${property.nameCapped}( target, mapper );
#end##FOREACH
[$jav]           }
[$jav]           return target;
[$jav]         }

MISCELLANEOUS METHODS BLOCK:
=====================================================================================================

[$jav]     /**
[$jav]      * Casts (without warning) the given list to a list of
[$jav]      * the current type.
[$jav]      * @throws ClassCastException
[$jav]      */
[$jav]     @SuppressWarnings("unchecked") public static List<${PojoI}> cast(List list) { return list; }

[$pyc]
[$pyc]       def ice_postUnmarshal(self):
[$pyc]           """
[$pyc]           Provides additional initialization once all data loaded
[$pyc]           """
[$pyc]           pass # Currently unused
[$pyc]
[$pyc]
[$pyc]       def ice_preMarshal(self):
[$pyc]           """
[$pyc]           Provides additional validation before data is sent
[$pyc]           """
[$pyc]           pass # Currently unused
[$pyc]
[$pyc]       def __getattr__(self, name):
[$pyc]           import __builtin__
[$pyc]           """
[$pyc]           Reroutes all access to object.field through object.getField() or object.isField()
[$pyc]           """
[$pyc]           if "_" in name:  # Ice disallows underscores, so these should be treated normally.
[$pyc]               return object.__getattribute__(self, name)
[$pyc]           field  = "_" + name
[$pyc]           capitalized = name[0].capitalize() + name[1:]
[$pyc]           getter = "get" + capitalized
[$pyc]           questn = "is" + capitalized
[$pyc]           try:
[$pyc]               self.__dict__[field]
[$pyc]               if hasattr(self, getter):
[$pyc]                   method = getattr(self, getter)
[$pyc]                   return method()
[$pyc]               elif hasattr(self, questn):
[$pyc]                   method = getattr(self, questn)
[$pyc]                   return method()
[$pyc]           except:
[$pyc]               pass
[$pyc]           raise AttributeError("'%s' object has no attribute '%s' or '%s'" % (self.__class__.__name__, getter, questn))
[$pyc]
[$pyc]       def __setattr__(self, name, value):
[$pyc]           """
[$pyc]           Reroutes all access to object.field through object.getField(), with the caveat
[$pyc]           that all sets on variables starting with "_" are permitted directly.
[$pyc]           """
[$pyc]           if name.startswith("_"):
[$pyc]               self.__dict__[name] = value
[$pyc]               return
[$pyc]           else:
[$pyc]               field  = "_" + name
[$pyc]               setter = "set" + name[0].capitalize() + name[1:]
[$pyc]               if hasattr(self, field) and hasattr(self, setter):
[$pyc]                   method = getattr(self, setter)
[$pyc]                   return method(value)
[$pyc]           raise AttributeError("'%s' object has no attribute '%s'" % (self.__class__.__name__, setter))
[$pyc]

END DECLARATION BLOCK:
=====================================================================================================

[$jav] }
[$hdr]  };
[$hdr]

[$cpp]}}
[$hdr]}}
[$hdr] #endif // ${POJOI}_H
[$ice]     };
[$ice]   };
[$ice] };
[$ice] #endif // ${POJO}_ICE
[$pyc] _omero_model.${PojoI} = ${PojoI}
#stop

